**业务系统有没做消息的重复消费处理，是怎么做的**

幂等性：一个请求，不管重复来多少次，结果是不会改变的

RabbitMQ、RocketMQ、Kafka等任何队列不保证消息不重复，如果业务需要消息不重复消费，

则需要消费端处理业务消息要保持幂等性

方式一：Redis的setNX() , 做消息id去重 java版本目前不支持设置过期时间

方式二：redis的 Incr 原子操作：key自增，大于0 返回值大于0则说明消费过，(key可以是消

息的md5取值, 或者如果消息id设计合理直接用id做key)

方式三：数据库去重表





**压缩是时间换空间，还是空间换时间？**

web层主要涉及浏览器和服务器的网络交互，而网络交互显然是耗费时间的

要尽量减少交互次数、降低每次请求或响应数据量。

因此开启压缩进行性能优化

在服务端是时间换空间的策略，服务端需要牺牲时间进行压缩以减小响应数据大小

压缩后的内容可以获得更快的网络传输速度，时间是得到了优化

所以是双向的





