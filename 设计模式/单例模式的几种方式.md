## 饿汉式

只要调用方法就会实例化

```java
// 问题1：为什么加 final，防止子类继承后更改
// 这里加final的原因是防止子类继承修改，从而破坏单例
// 实现序列化接口可能会破坏单例，因为反序列化时会生成新的对象
public final class Singleton implements Serializable {
    // 设置私有构造的原因就是防止其他类调用构造方法实例化
    // 需要注意不能防止反射创建新的实例，反射是可以强行调用创建
    private Singleton() {}
    // 这里使用static静态变量是因为类加载是就会先加载一次静态变量
    // jvm在类加载阶段就进行了初始化，jvm保证了此操作的线程安全性
    private static final Singleton INSTANCE = new Singleton();
    // 为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。
    // 1.提供更好的封装性；2.提供范型的支持
    public static Singleton getInstance() {
        return INSTANCE;
    }
    //要解决反序列化生成新对象，需要添加该方法，这样保证反序列化也是返回这个对象
    public Object readResolve() {
        return INSTANCE;
    }
}
```

还可以将实例化放在静态代码块中

```java
static{
	INSTANCE = new Singleton();
}
```



## 对于枚举类

```JAVA
// 问题1：枚举单例是如何限制实例个数的：创建枚举类的时候就已经定义好了，每个枚举常量其实就是枚举类的一个静态成员变量
// 问题2：枚举单例在创建时是否有并发问题：没有，这是静态成员变量
// 问题3：枚举单例能否被反射破坏单例：不能
// 问题4：枚举单例能否被反序列化破坏单例：枚举类默认实现了序列化接口，枚举类已经考虑到此问题，无需担心破坏单例
// 问题5：枚举单例属于懒汉式还是饿汉式：饿汉式
// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做：加构造方法就行了
enum Singleton {
 INSTANCE;
}
```



## 懒汉式

为空的时候再去加载

线程安全的

同时也有线程不安全的，那就是不使用`synchroniaed`

```java
public final class Singleton {
    private Singleton() { }
    private static Singleton INSTANCE = null;
    // 分析这里的线程安全, 并说明有什么缺点：synchronized加载静态方法上，可以保证线程安全。缺点就是锁的范围过大
    public static synchronized Singleton getInstance() {
        if( INSTANCE != null ){
            return INSTANCE;
        }
        INSTANCE = new Singleton();
        return INSTANCE;
    }
}
```



## DCL 懒汉式

```java
public final class Singleton {
    private Singleton() { }
    // 问题1：解释为什么要加 volatile ?为了防止重排序问题
    private static volatile Singleton INSTANCE = null;

    // 问题2：对比实现3, 说出这样做的意义：提高了效率
    public static Singleton getInstance() {
        if (INSTANCE != null) {
            return INSTANCE;
        }
        synchronized (Singleton.class) {
            // 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗？
            // 如果线程1执行到这里了，刚好有个线程2也执行在这里并等待锁释放
            // 现在线程1执行完了，也创建完了，这个时候线程2得到锁进来，又会创建一次
            if (INSTANCE != null) { 
                return INSTANCE;
            }
            INSTANCE = new Singleton();
            return INSTANCE;
        }
    }
}
```

--

下面这个方法能都在类使用时才会去创建实例

```java
public final class Singleton {
    private Singleton() { }
    // 问题1：属于懒汉式还是饿汉式：懒汉式，这是一个静态内部类。类加载本身就是懒惰的，在没有调用getInstance方法时是没有执行LazyHolder内部类的类加载操作的。
    private static class LazyHolder {
        static final Singleton INSTANCE = new Singleton();
    }
    // 问题2：在创建时是否有并发问题，这是线程安全的，类加载时，jvm保证类加载操作的线程安全
    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }
}
```

