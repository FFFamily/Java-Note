# 数据库补充笔记

## 基础知识

### 一条SQL查询语句是如何执行的？

连接器：负责跟客户端建立连接、获取权限、维持和管理连接。

查询缓存：查询请求先访问缓存(key 是查询的语句，value 是查询的结果)。命中直接返回。

> 关闭缓存：参数 query_cache_type 设置成 DEMAND
>
> 不推荐使用缓存，更新会把缓存清除
>
> 因为表的每次更新都会清除掉缓存，而且这样的动作是经常发生的，所以有可能缓存才放好，就被删除了

分析器：对 SQL 语句做解析，判断sql是否正确。

优化器：决定使用哪个索引，多表关联（join）的时候，决定各个表的连接顺序。

执行器：执行语句，先判断用户有无查询权限，使用表定义的存储引擎。



### 一条SQL更新语句是如何执行的？

先写日志，再写磁盘

当记录更新时，Innodb 先记录 redo log 再更新内存，这时更新就算完成。引擎往往会在系统空闲时刷盘

具体就涉及到MYSQL的Crash-Safe

> innodb_flush_log_at_trx_commit参数：
>
> 0：log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作
>
> 1：每次事务提交时MySQL都会把log buffer的数据写入log file，并且flush(刷到磁盘)中去，该模式为系统默认。
>
> 2：每次事务提交时MySQL都会把log buffer的数据写入log file，但是flush(刷到磁盘)操作并不会同时进行。该模式下，MySQL会每秒执行一次 flush(刷到磁盘)操作。



### Crash-Safe

bin log：归档日志，利用归档日志恢复数据库数据

redo log（物理日志）：记录某个数据页上做了什么修改

undo log：

两阶段 提交：在修改的数据更新到内存后，需要刷盘进磁盘，此时Mysql就会将记录写入到redo log 日志中，同时进入 prepare 阶段，再写入bin log，在提交事务，刷盘，进入 commit 阶段。

> 提问，可不可不要 写入 redo log 的过程，直接写入到 bin log 中？

追问 1：MySQL 怎么知道 binlog 是完整的?
回答：一个事务的binlog是有完整格式的：

statement 格式的 binlog，最后会有 COMMIT；
row 格式的 binlog，最后会有一个 XID event。
mysql 5.6.2版本以后，引入binlog-checksum验证binlog内容是否正确。

追问 2：redo log 和 binlog 是怎么关联起来的？
回答：它们有个共同的数据字段：XID。

追问 3：处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?
回答：因为写入binlog后，会被从库使用，为了保证主备一致性。

追问 4：如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？
回答：两阶段提交是经典分布式系统问题，并不是mysql独有的。
innodb，如果redo log提交完成，事务就不能回滚（如果还允许回滚，可能覆盖掉别的事务的更新）。但如果redo log直接提交，binlog写失败时，innodb回滚不了 ，数据和binlog日志会不一致。两阶段提交就是为了每个“人”都ok，在一起提交。

追问 5：不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？
回答：不可以，历史原因，innodb不是mysql原生引擎，binlog不支持崩溃恢复，所以innodb实现了redo log。

追问 6：那能不能反过来，只用 redo log，不要 binlog
回答：如果从崩溃恢复角度来讲是可以的。但redo log是循环写，历史日志没法保留，而binlog有归档功能。binlog还有可以实现复制主从同步。

追问 7：redo log 一般设置多大？
回答：redo log太小会导致很快写满，然后就会强行刷redo log。如果几个TB硬盘，直接将redo log设置为4个文件，每个文件1G。

追问 8：正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？
回答：这个问题就是“redo log 里面到底是什么”的问题。
redo log没有记录数据页完整数据，所以它没有能力自己去更新磁盘数据页。

如果再次运行的实例，数据页被修改，跟磁盘数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这过程和redo log毫无关系。
在崩溃恢复场景，Innodb如果判断一个数据页可能在崩溃恢复时丢失更新，就会将它读到内存，然后让redo log更新内存内容。更新完成内存也变成脏页，就回到第一种情况。

追问 9：redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？
回答：在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：

```
begin;
insert into t1 ...
insert into t2 ...
commit;
这个事务往两个表中插记录过程中，生成的日志都要先保存起来，但不能在未commit的时候写到redo log里。
所以redo log buffer就是一块内存，用来先存redo日志。也就是说，在执行第一个 insert 的时候，数据的内存被修改了，redo log buffer 也写入了日志。
但是，真正写redo log文件（文件名是ib_logfile+数字），是在执行commit时做的。
单独执行一个更新语句，innodb会自己启动一个事务，过程和上述内容一致。
```

### count 的效率问题

count(字段)<count(主键 id)<count(1)≈count(*)，所以建议尽量使用 count(*)。



## 存储引擎

### InnoDb

是 MySQL 默认的事务型存储引擎，**只有在需要它不支持的特性时，才考虑使用其它存储引擎**。

实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻影读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

### MyIsam

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

**不支持事务**。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作



### 比较

事务：InnoDb支持事务，MyIsam不支持

锁：InnoDb支持行锁、表锁，MyIsam支持表锁、无行锁

外键：InnoDb支持外键

备份: InnoDB 支持在线热备份

崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢

索引：InnoDb索引data域放的是数据实体，MyIsam放的是数据索引

其他特性：MyIsam支持全文检索、压缩、空间函数，而InnoDb不支持

MyIsam查找总行数时不需要全盘扫描，而InnoDb需要全盘扫描

**innodb**是基于B+Tree索引建立的，和myisam相反它支持事务、外键，并且通过MVCC来支持高并发，索引和数据存储在一起。

### 面试

> 其他链接
>
> https://blog.csdn.net/zsq520520/article/details/68954646



#### InnoDb与MyIsam索引上的区别

MyIsam 与 InnDB 都是使用B+树

不同的是

> 前者data存的是数据的地址
>
> 后者data存的是完整的数据记录
>
> 一个存地址，一个存数据



因为InnoDB 的数据文件本身要按主键聚集，所以

InnoDB 要求表必须有主键（MyISAM 可以没有），如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整形



这里也涉及到主键为什么要设置为自增的原因

（在笔记中有提到）



#### 主键为什么要设置为自增的原因





## 索引

### InnoDb的索引实现

因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。

可以指定多个列作为索引列，多个索引列共同组成键。

适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

InnoDB 的 B+Tree 索引分为主索引和辅助索引。

主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

> 这里也就涉及一个回表查询的操作



### 分类

#### B+Tree 索引

是大多数 MySQL 存储引擎的默认索引类型。

> 以上有介绍



#### 哈希索引

哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制:

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。



#### 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引



#### 空间数据索引

MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用 GIS 相关的函数来维护数据



### 优点

索引通常远小于数据行的大小，只读取索引能大大减少数据访问量，加快检索速度

一些存储引擎(例如 MyISAM)在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用(通常比较费时)。

> 以下可以回答为
>
> 可以利用索引的一些特性，做出一些操作
>
> 比如覆盖索引，唯一索引。。。

对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引，避免了回表。

唯一性索引能保证数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能



### 缺点

创建和维护索引消耗时间

索引占用物理空间

对表中的数据进行增加，删除，修改的同时，索引也需要维护，这也属于表中索引不能过多的原因的一种





### 索引的使用场景

对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。

对于中到大型的表，索引就非常有效。为经常需要排序、分组和联合操作的字段建立索引

但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

索引值不能太长，个人理解是 索引值太长起不到目录的作用

要考虑索引失效的情况，最左前缀匹配原则



### 面试

#### 什么是B+树？

B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。



添加元素

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性





#### 为什么B+树成为主要的SQL数据库的索引实现？

1，B+树只有叶子节点存放数据，而其他节点只存放索引，而 B 树每个节点都有 Data 域，所以相同大小的 B+树包含的索引比 其他树的索引更多，一次性读入内存中的需要查找的关键字也就越多，因此B+树的磁盘读写代价更低

2，还有就是 B+树的叶子节点是通过链表连接的，所以找到下限后能很快进行区间查询

3，减少随机io，B+树在叶子结点才会找到数据，而B树在非叶子结点就能找到，所以对于数据库中频繁使 用的 range query，B+树有着更高的性能。

> 随机io读取
>
> 树高度
>
> 查询方式



#### 和红黑树的比较起来为什么文件系统及数据库系统普遍采用 B+ Tree 作为索引结构？

(一)更少的查找次数

平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O(h)=O(logdN)，其中 d 为每个节点的出度。

红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，检索的次数也就更多。

> 树的深度过大会造成磁盘 IO 频繁读写。根据磁盘查找存取的次数往往由树的高度所决定。



> 我们假设 B+树一个节点可以有 100 个关键字，那么 3 层的 B 树可以容纳大概 1000000 多个关键字。而红黑树要存储这么多至少要 20 层。所以
>
> 使用 B 树相对于红黑树和 AVL 可以减少 IO 操作

(二)利用计算机预读特性，减少I/O

为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，因此速度会非常快。

操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能够被预先载入。



#### 为什么性别不适合建立索引

首先，我们知道，性别的可重复性也就意味着只能对性别建立非聚集索引

> 非聚集索引也就意味着可能有回表的问题

因为访问时会进行额外的io开销

我们扫描索引拿到的是地址，需要在进行一次iO查询才能拿到数据

有100万的数据，取50万的数据，先访问50万次索引，然后访问50万次数据，加起来的开销和全盘扫描差不多了



#### 唯一索引与主键索引的区别

唯一索引是索引，主键索引是约束，本质上不同

主键包含唯一索引

唯一索引允许为空，主键不允许

可以有多个唯一索引，不能有多个主键



#### 复合索引使用需要注意什么

考虑查询索引是否生效问题



#### 如何判断是否为聚集索引







## 锁

### 间隙锁



## 范式

1NF
		每列都是不可再分的最小数据单元
2NF
		非主键字段都依赖于主键字段
3NF
		不存在传递依赖，非主键外的所有字段必须互不依赖
BCNF
		非主属性不能对主键子集依赖
4NF
		同一表内的多对多关系删除
5NF



## 事务

### ACID

原子性

要么都执行，要么都不执行，各操作不可再分



隔离性

事务之间彼此隔离，互不影响



一致性

事务完成前后状态一致

> 例子
>
> 有个完整性约束 a+b = 10
>
> 一个事务修改了a之后，也必须修改b
>
> 在事务执行前，都有一个一致性状态，在事务执行后，这个一致性状态也需要保持一致

事务是数据库维护一致性的单位。



永久性

事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性



### 隔离级别

InnoDb默认是可重复读

> Spring事务默认使用数据库的隔离级别，可以通过注解@Transactional中的isolation参数调整Session级的隔离级别。隔离级别是会话级别的





未提交度（Read UnCommitted）

> 事务没有提交，对于其他事务是可见的



提交读(Read Committed)

> 一个事务提交前，对其他事务不可见。会有，幻读，不可重复读



可重复读(Repeatable Read)

> 一个事务多次读取同样的数据，幻读，解决脏读，不可重复读



可串行化(Serializable)

> 强制事务串行执行，会在读取的每一行加锁





### 数据库中并发一致性问题

脏读

> 事务可以读到未提交的数据，称为脏读

幻读

> 一个事务连续读取数据时，另外一个事务插入添加了一行数据，导致读多了一行数据（幻行）

重复度

> 同一事务多次读取，结果不一样

丢失修改

> T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。



### 面试

#### 什么是事务？

所谓事务，就是一个操作序列，这些操作要么实行，要么都不执行

#### InnoDb通过什么实现事务

> 事务的实现原理

回答这问题，首先会联想到事务的4个特性：ACID

事务必须得保证这四个特性，否则就无法保证数据的正确性，也就是InnoDb通过什么来保证这几个特性

一，几个日志文件

> 通过Buffer Pool，Log Buffer，Redo log，Undo log实现

二，锁机制和多版本并发控制MVCC



#### Spring传播行为有了解过吗？



#### Buffer Pool、Redo Log Buffer 、undo log、redo log、bin log 概念以及关系？

Buffer Pool 是 MySQL 的一个非常重要的组件，因为针对数据库的增删改操作都是在 Buffer Pool 中完成的

Undo log 记录的是数据操作前的样子

redo log 记录的是数据被操作后的样子（redo log 是 Innodb 存储引擎特有）

bin log 记录的是整个操作记录（这个对于主从复制具有非常重要的意义）



#### 从准备更新一条数据到事务的提交的流程描述？

首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中

在数据被缓存到缓存池的同时，会写入 undo log 日志文件

更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中

完成以后就可以提交事务，在提交的同时会做以下三件事 

- 将redo log buffer中的数据刷入到 redo log 文件中
- 将本次操作记录写入到 bin log文件中
- 将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记



#### ACID靠什么保证

原子性：由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql

隔离性：MVCC来保证

一致性：一般由代码层面来保证

永久性：由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复

binlog的写入机制

redo log 的写入机制





#### Mysql突然慢的原因

刷脏页

innodb的**redo log写满**了

buffer pool内存不足，此时需要淘汰一些数据页，有可能会淘汰脏页，就要先把脏页刷到磁盘。

> 刷脏页一定会写盘，就保证了每个数据页有两种状态：
>
> a. 内存里的一定是正确数据
>
> b. 内存里没有，磁盘上的一定是正确数据。

mysql正常关闭。



## 并发策略





## MVCC

