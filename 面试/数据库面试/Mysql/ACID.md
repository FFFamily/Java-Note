# ACID

## ACID靠什么保证



事务必需要具有这四种特性，否则在无法保证数据的正确性



### 原子性 

由undo log日志保证，它记录了需要回滚的日志信息，事务回滚是撤销已经成功执行的sql

为了保证事务操作的原子性，必须实现基于日志的REDO/UNDO机制

#### undo log（回滚日志）

> 相似的事务日志还有很多：redo log（重做日志）、二进制日志、错误日志等

当事务对数据库进行修改时，InnoDB会生成对应的undo log，记录了sql的执行情况；

如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子



### 一致性

> 所谓一致性，指的是数据处于一种有意义的状态，这种状态是**语义上的**而不是**语法上的**。
>
> 最常见的例子是转帐
>
> 例如从帐户A转一笔钱到帐户B上，如果帐户A上的钱减少了，而帐户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态
>
> 如何理解一致性
>
> 数据库事务的ACID特征中，AID都是和数据库有感，C与应用层有关，由代码控制
>
> 好比银行转账：A-100 B+100 前后的数据保持不变，100没有凭空消失，也没有凭空产生
>
> AID是手段，C是目的
>
> 其他都是为C服务的



**一致性是最基本的属性**，其它的三个属性都为了保证一致性而存在的。由其他三大特性保证、程序代码要保证业务上的一致性。

一致性可以分为数据库外部的一致性和数据库内部的一致性。

前者由外部应用的编码来保证，即某个应用在执行转帐的数据库操作时，必须在同一个事务内部调用对帐户A和帐户B的操作。

如果在这个层次出现错误，这不是数据库本身能够解决的，也不属于我们需要讨论的范围。

后者由数据库来保证，即在同一个事务内部的一组操作必须全部执行成功（或者全部失败），这就是事务处理的原子性。



为了保证并发情况下的一致性，引入了隔离性，即保证每一个事务能够看到的数据总是一致的，就好象其它并发事务并不存在一样。



### 隔离性 

- (一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性
- (一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性



### 持久性 

由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redo log 恢复。

> InnoDb redo log 写盘 ，InnoDB事务进入prepare状态。
>
> 如果前面prepare成功，binlog写盘，再继续将事务日志持久化到binlog
>
> 如果持久化成功，那么InnoDb事务则进入commit状态。（在redo log里面写一个commit记录）

确保事务执行成功的一个重要判断指标就是 在redo log中此事务是否有commit记录。

redo log刷盘会在系统空闲时进行。

#### redo log

InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。

Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。

于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（==Write-ahead logging，预写式日志==），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。

既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？

主要有以下两方面的原因：

（1）刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。

（2）刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。

> 刷脏同时会带来数据库突然执行很慢，原因是SQL执行过程中，缓存满了，这个时候就会暂停其他的SQL操作，刷脏后再开放执行



#### redo log与binlog

我们知道，在MySQL中还存在binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的：

（1）作用不同：redo log是用于crash recovery的，保证MySQL宕机也不会影响持久性；binlog是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外binlog还用于主从复制。

（2）层次不同：redo log是InnoDB存储引擎实现的，而binlog是MySQL的服务器层实现的，同时支持InnoDB和其他存储引擎。

（3）内容不同：redo log是物理日志，内容基于磁盘的Page；binlog的内容是二进制的，根据binlog_format参数的不同，可能基于sql语句、基于数据本身或者二者的混合。

（4）写入时机不同：binlog在事务提交时写入；redo log的写入时机相对多元：

当事务提交时会调用fsync对redo log进行刷盘；这是默认情况下的策略，修改innodb_flush_log_at_trx_commit参数可以改变该策略，但事务的持久性将无法保证。除了事务提交时，还有其他刷盘时机：如master thread每秒刷盘一次redo log等，这样的好处是不一定要等到commit时刷盘，commit速度大大加快。



## bin log的写入机制

binlog 的写入逻辑比较简单：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中



## redo log 的写入机制



