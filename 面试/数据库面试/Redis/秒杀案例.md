# 秒杀案例

## 未整合springboot实例代码

```java
//秒杀过程
public static boolean doSecKill(String uid,String prodid) throws IOException {
    //1 uid和prodid非空判断
    if(uid == null || prodid == null) {
        return false;
    }

    //2 连接redis
    //Jedis jedis = new Jedis("loclahost",6379);
    //通过连接池得到jedis对象
    JedisPool jedisPoolInstance = JedisPoolUtil.getJedisPoolInstance();
    Jedis jedis = jedisPoolInstance.getResource();

    // 拼接key
    // 库存key
    String kcKey = "sk:"+prodid+":qt";
    // 秒杀成功用户key
    String userKey = "sk:"+prodid+":user";

    // 监视库存
    jedis.watch(kcKey);

    // 获取库存，如果库存null，秒杀还没有开始
    String kc = jedis.get(kcKey);
    if(kc == null) {
        System.out.println("秒杀还没有开始，请等待");
        jedis.close();
        return false;
    }

    // 判断用户是否重复秒杀操作
    if(jedis.sismember(userKey, uid)) {
        System.out.println("已经秒杀成功了，不能重复秒杀");
        jedis.close();
        return false;
    }

    // 判断如果商品数量，库存数量小于1，秒杀结束
    if(Integer.parseInt(kc)<=0) {
        System.out.println("秒杀已经结束了");
        jedis.close();
        return false;
    }

    // 使用事务
    // 使用事务的原因是存在商品超卖的问题
    // 所以需要开启事务，在有其他线程修改的时事务关闭，这样就能防止库存负值
    Transaction multi = jedis.multi();

        //组队操作
        multi.decr(kcKey);
        multi.sadd(userKey,uid);

    //执行
    List<Object> results = multi.exec();

    if(results == null || results.size()==0) {
        System.out.println("秒杀失败了....");
        jedis.close();
        return false;
    }

    //7.1 库存-1
    //jedis.decr(kcKey);
    //7.2 把秒杀成功用户添加清单里面
    //jedis.sadd(userKey,uid);

    System.out.println("秒杀成功了..");
    jedis.close();
    return true;
}
```



## redis连接池

使用连接池可以是解决连接的超时问题

因为当有很多请求到达的时候，Redis是无法应付过来的，没有被执行的请求就会等待，超过一定的时间就会异常

```java
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;
// 连接池工具类
public class JedisPoolUtil {
    private static volatile JedisPool jedisPool = null;
	// 私有构造方法，单例
    private JedisPoolUtil() {}

    public static JedisPool getJedisPoolInstance() {
        if (null == jedisPool) {
            synchronized (JedisPoolUtil.class) {
                if (null == jedisPool) {
                    JedisPoolConfig poolConfig = new JedisPoolConfig();
                    poolConfig.setMaxTotal(200);
                    poolConfig.setMaxIdle(32);
                    poolConfig.setMaxWaitMillis(100*1000);
                    poolConfig.setBlockWhenExhausted(true);
                    poolConfig.setTestOnBorrow(true);  // ping  PONG

                    jedisPool = new JedisPool(poolConfig, "loclahost", 6379, 60000);
                }
            }
        }
        return jedisPool;
    }

    public static void release(JedisPool jedisPool, Jedis jedis) {
        if (null != jedis) {
            jedisPool.returnResource(jedis);
        }
    }

}

```



## 库存遗留问题

打比方，现在有2000个线程抢购，商品有200个，按道理200个全部能卖出去

但是现在还有遗留

原因是乐观锁让很多其他的线程的请求都失效了，导致先点的拿不到，后点的得到了

处理是使用脚本

LUA**脚本**

> 原理：
>
> 将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。
>
> 提升性能。



```java
local userid=KEYS[1]; //获取第一个参数
local prodid=KEYS[2]; // 获取去第二个参数
local qtkey="sk:"..prodid..":qt"; // 拼接字符串
local usersKey="sk:"..prodid.":usr'; 
// 查看是否重复
local userExists=redis.call("sismember",usersKey,userid);
if tonumber(userExists)==1 then 
    return 2;
end
    local num= redis.call("get" ,qtkey);
if tonumber(num)<=0 then 
    return 0; 
else 
    redis.call("decr",qtkey);
redis.call("sadd",usersKey,userid);
end
    return 1;
```

那么代码就会转为

```java
public class SecKill_redisByScript {

    private static final  org.slf4j.Logger logger =LoggerFactory.getLogger(SecKill_redisByScript.class) ;

    public static void main(String[] args) {
        JedisPool jedispool =  JedisPoolUtil.getJedisPoolInstance();

        Jedis jedis=jedispool.getResource();
        System.out.println(jedis.ping());

        Set<HostAndPort> set=new HashSet<HostAndPort>();

        //	doSecKill("201","sk:0101");
    }

    static String secKillScript ="local userid=KEYS[1];\r\n" + 
        "local prodid=KEYS[2];\r\n" + 
        "local qtkey='sk:'..prodid..\":qt\";\r\n" + 
        "local usersKey='sk:'..prodid..\":usr\";\r\n" + 
        "local userExists=redis.call(\"sismember\",usersKey,userid);\r\n" + 
        "if tonumber(userExists)==1 then \r\n" + 
        "   return 2;\r\n" + 
        "end\r\n" + 
        "local num= redis.call(\"get\" ,qtkey);\r\n" + 
        "if tonumber(num)<=0 then \r\n" + 
        "   return 0;\r\n" + 
        "else \r\n" + 
        "   redis.call(\"decr\",qtkey);\r\n" + 
        "   redis.call(\"sadd\",usersKey,userid);\r\n" + 
        "end\r\n" + 
        "return 1" ;

    static String secKillScript2 = 
        "local userExists=redis.call(\"sismember\",\"{sk}:0101:usr\",userid);\r\n" +
        " return 1";

    public static boolean doSecKill(String uid,String prodid) throws IOException {

        JedisPool jedispool =  JedisPoolUtil.getJedisPoolInstance();
        Jedis jedis=jedispool.getResource();

        //String sha1=  .secKillScript;
        String sha1=  jedis.scriptLoad(secKillScript);
        Object result= jedis.evalsha(sha1, 2, uid,prodid);

        String reString=String.valueOf(result);
        
        if ("0".equals( reString )  ) {
            System.err.println("已抢空！！");
        }else if("1".equals( reString )  )  {
            System.out.println("抢购成功！！！！");
        }else if("2".equals( reString )  )  {
            System.err.println("该用户已抢过！！");
        }else{
            System.err.println("抢购异常！！");
        }
        jedis.close();
        return true;
    }
}
```

