# 继承

 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为



> 子类又被称为派生类
>
> 父类又被称为超类



## 关键字

继承可以使用 **extends** 和 **implements**  这两个关键字来实现继承



继承层次：由一个公共超类派生出来的所有类的集合

继承链：继承层次中，从某个特定类到其他祖先的路径



**注意：**

继承关系之中，如果要实例化子类对象，会默认先调用父类构造，为父类之中的属性初始化，之后再调用子类构造，为子类之中的属性初始化

即：默认情况下，子类会找到父类之中的无参构造方法。

现在默认调用的是无参构造，而如果这个时候父类没有无参构造，则子类必须通过super()调用指定参数的构造方法



## 继承类型

![img](E:\有道云笔记\新建文件夹\qqA18D73086F0D435363C26D86B8CAD5E6\b81695219f214116b773a0ee8c5831d7\dfm4byfk.bmp)



## 继承特性

- 子类拥有父类非 private 的属性、方法
- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展
- 子类可以用自己的方式实现父类的方法
- 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）
- final类是不允许扩展的



## super 与 this 关键字

```java
class A{
    public void a(){ b() }
    public void b(){     }
}

class B extend A {
    public void a(){
        super.a();
    }
    public void b(){}
}

```



额外注意：

1，只要被子类重写的方法，不被super调用都是调用子类方法

2，**super关键字必须在构造方法的第一行 ，子类构造函数第一行默认就是super()**

```java
public class A {
    public A(){
        System.out.println("A");
    }
    public static void main(String[] args) {
        new A().a();
    }
}
----------------------------------------------------------
public class B  extends  A{
    public B(){
        System.out.println("B");
    }
    public static void main(String[] args) {
        new B().a();
    }
}
//输出的是A B
//如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错
```

3，final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写



构造方法

如果子类没有显式的调用父类构造器，那么会自动的调用超类默认（没有参数）的构造器

如果超类没有不带参数的构造器，并且子类又没有显式的调用超类的其他构造器，编译报错



### 面试题

#### this() & super()在构造方法中的区别？

- 调用super()必须写在子类构造方法的第一行, 否则编译不通过
- super从子类调用父类构造, this在同一类中调用其他构造均需要放在第一行
- 尽管可以用this调用一个构造器, 却不能调用2个
- this和super不能出现在同一个构造器中, 否则编译不通过
- this()、super()都指的对象,不可以在static环境中使用
- 本质this指向本对象的指针。super是一个关键字

#### 

## 重载与重写



### 重载



表示同一个类中可以有

- 名称相同
- 方法的参数列表各不相同（即参数个数和类型不同）	
- 方法返回值可以不同																				



注意

1 ，在使用重载的时候只能通过不同的参数样式

2 ，不能通过访问权限，返回类型，抛出的异常进行重载

3 ，方法的异常类型不会对重载造成影响

4 ，对于继承来说，如果父类的访问权限是private，那么就不能在子类中进行重载，定义的话，也是相当于在子类中增加了一个新的方法

5，方法的返回值与重载无关







### 重写																																																																																				

- 参数相同
- 把父类中定义的那个完全相同的方法给覆盖了

 

注意

1，如果父类的方法的类型的是**private类型**，那么，子类则**不存在覆盖的限制**，则相当于子类增加了一个全新的方法。

2，覆盖的方法的标志必须要和被覆盖的**方法的标志完全匹配**，才能达到覆盖的效果。

3，覆盖的方法的返回值必须和被覆盖方法的**返回值一致**。

> 额外注意：但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的

4，覆盖的方法所抛出的异常必须和被覆盖方法的**所抛出的异常一致**，或者是其异常的子类。

5，子类的访问权限只能比父类大，不能比父类小。子类若想访问父类私有变量，需要借助接口（super）

> super是一个关键字，调用super的语句必须放在子类构造器的第一条语句
>
> ```java
> super.getnumber()
> ```



小技巧

> **两同两小一大**

- “两同”即方法名相同、形参列表相同；
- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。





## 类的加载顺序

(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)

(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )

(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )

(4) 父类构造函数

(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )

(6) 子类构造函数



代码块的执行顺序

父类的静态->子类的静态->父类的非静态->父类的构造->子类的非静态->子类的构造





# 多态

多态是同一个行为具有多个不同表现形式或形态的能力。

多态的特征是表现出多种形态，具有多种实现方式。或者多态是具有表现多种形态的能力的特征。或者同一个实现接口，使用不同的实例而执行不同的操作。

  

```java
//多态
Employee e;
e = new Employee();
e = new Manager();

//额外注意不能将超类的引用赋值给子类变量
Manager m = new Employee();
```



作用:

  1，可以增强程序的可扩展性及可维护性，使代码更加简洁。

  2，不但能减少编码的工作量，也能大大提高程序的可维护性及可扩展性



## 三个必要条件

继承，重写，父类引用指向子类对象

当使用多态方式调用方法时，**首先检查父类中是否有该方法**，如果没有，则编译错误；如果有，再去调用子类的同名方法



## 实现方式

方式一：重写

方式二：接口

方式三：抽象类和抽象方法



## 抽象类（abstract）

在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，**并不是所有的类都是用来描绘对象的**，如果**一个类中没有包含足够的信息来描绘一个具体的对象**，这样的类就是**抽象类**。



特点：

1，不能实例化对象

2，抽象类必须被继承



## 抽象方法

**抽象方法只包含一个方法名，而没有方法体**

抽象方法没有定义，**方法名后面直接跟一个分号**，而不是花括号。



注意

- **如果一个类包含抽象方法，那么该类必须是抽象类**
- **任何子类必须重写父类的抽象方法**，**或者声明自身为抽象类**
- **不能被final修饰**



## 方法调用

1，编译器查看对象的声明类型和方法名，父类和子类同名的方法一一列举出来

2，编译器查看调用方法时提供的参数类型

> 重载解析：在所有名为F的方法中存在一个与提供参数类型完全匹配，那就选择那个方法

3，如果是private方法，static方法，final方法或者构造器，那么编译器可以准确的知道应该调用哪个方法（静态绑定）

4，程序运行时，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最符合的那个类方法

> 每次调用都需要搜索，开销大，所以虚拟机预先为每个类创建了一个方法表，这样就只需要查表调用就可以

