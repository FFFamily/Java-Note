# 动态代理

> 笔记出自《javaGuide》

## 代理模式

我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。

**代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作**



> 代理模式分两种：静态和动态

### 静态代理

> **静态代理中，我们对目标对象的每个方法的增强都是手动完成的**

实现步骤

1. 定义一个接口及其实现类；
2. 创建一个代理类同样实现这个接口
3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。

实现

```java
//接口方法
public interface inter {
    public void f();
}
```

--

```java
// 接口实现类
public class interImpl implements inter {
    public void f(){
        //方法实现
    }
}
```

--

```java
//代理类
public class MyProxy implements inter {
	private inter inter;
	public void MyProxy(inter inter){
		this.inter = inter;
	}
    public void f(){
    	//方法执行前执行方法
    	before();
    	//被代理执行的方法
    	inter.f();
    	//方法执行后执行方法
    	after();
    }
}
```



### 动态代理

我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( *CGLIB 动态代理机制*)。

**从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。**

> Spring AOP、RPC 框架它们的实现都依赖了动态代理。



#### JDK动态代理

使用步骤

1. 定义一个接口及其实现类；
2. 自定义 `InvocationHandler` 并重写`invoke`方法，在 `invoke` 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
3. 通过 `Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)` 方法创建代理对象；

实现

> **JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。**

```java
//接口方法
public interface inter {
    public void f();
}
```

--

```java
// 接口实现类
public class interImpl implements inter {
    public void f(){
        //方法实现
    }
}
```

--

```java
//代理类
public class MyProxy implements InvocationHandler {
    /**
     * 代理类中的真实对象
     */
    private final Object target;
    public MyProxy(Object target) {
        this.target = target;
    }

    /**
     * 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 invoke() 方法，然后 invoke() 方法代替我们去调用了被代理对象的原生方法。
     * @param o 动态生成的代理类
     * @param method 方法
     * @param objects 方法参数
     * @return
     * @throws Throwable
     */
    @Override
    public Object invoke(Object o, Method method, Object[] objects) throws Throwable {
        System.out.println("object:"+o.getClass());
        //调用方法之前，我们可以添加自己的操作
        System.out.println("before method " + method.getName());
        Object result = method.invoke(target, objects);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method " + method.getName());
        return result;
    }
}
```

--

```java
//获取代理类的工厂方法
public class JdkProxyFactory {
    /**
     * 主要通过Proxy.newProxyInstance（）方法获取某个类的代理对象
     * @param target
     * @return
     */
    public static Object getProxy(Object target){
        return Proxy.newProxyInstance(
                target.getClass().getClassLoader(),// 目标类的类加载
                target.getClass().getInterfaces(),// 代理需要实现的接口，可指定多个
                new reftest(target)// 代理对象对应的自定义
        );
    }
}
```

--

```java
inter t = (inter) JdkProxyFactory.getProxy(new interImpl());
```



####  CGLIB 动态代理

使用步骤

1. 定义一个类；
2. 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，和 JDK 动态代理中的 `invoke` 方法类似；
3. 通过 `Enhancer` 类的 `create()`创建代理类；

其所需依赖

```xml
<dependency>
  <groupId>cglib</groupId>
  <artifactId>cglib</artifactId>
  <version>3.3.0</version>
</dependency>
```

实现

```java
public class service {
    public void send(String message) {
        System.out.println("send message:" + message);
    }
}
```

--

```java
public class DebugMethodInterceptor implements MethodInterceptor {
    /**
     * @param o           被代理的对象（需要增强的对象）
     * @param method      被拦截的方法（需要增强的方法）
     * @param args        方法入参
     * @param methodProxy 用于调用原始方法
     */
    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        //调用方法之前，我们可以添加自己的操作
        System.out.println("before method " + method.getName());
        Object object = methodProxy.invokeSuper(o, args);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method " + method.getName());
        return object;
    }

}
```

--

```java
public class CglibProxyFactory {

    public static Object getProxy(Class<?> clazz) {
        // 创建动态代理增强类
        Enhancer enhancer = new Enhancer();
        // 设置类加载器
        enhancer.setClassLoader(clazz.getClassLoader());
        // 设置被代理类
        enhancer.setSuperclass(clazz);
        // 设置方法拦截器
        enhancer.setCallback(new DebugMethodInterceptor());
        // 创建代理类
        return enhancer.create();
    }
}
// 调用
service aliSmsService = (service) CglibProxyFactory.getProxy(service.class);
```



#### 两者对比

- **JDK 动态代理只能只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类**
- CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。
- JDK动态代理效率更高



### 两者对比（静态/动态）

1. **灵活性** ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
2. **JVM 层面** ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。