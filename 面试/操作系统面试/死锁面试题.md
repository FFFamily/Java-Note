# 死锁面试题

## 1，什么是死锁

多个进程同时竞争资源造成的一种僵局



## 2，死锁产生的原因

（1）竞争资源
系统中的资源可以分为两类：
1.可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；

2.不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。

产生死锁中的竞争资源之一指的是竞争不可剥夺资源

> 例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞

产生死锁中的竞争资源另外一种资源指的是竞争临时资源，通常消息通信顺序进行不当，则会产生死锁

> 临时资源包括硬件中断、信号、消息、缓冲区内的消息等4ff4 

（2）进程间推进顺序非法
若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁

> 当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；
>
> 当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁
>



## 3，死锁产生的必要条件

（1）互斥条件：

进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。

（2）请求和保持条件：

当进程因请求资源而阻塞时，对已获得的资源保持不放。

（3）不剥夺条件：

进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。

（4）环路等待条件：

在发生死锁时，必然存在一个进程–资源的环形链。



## 4，预防死锁（需要自己代码实现）

破坏四个必要条件之一就可以

（1）破坏“互斥”条件:

就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。

但一般来说在所列的四个条件中，“互斥”条件是无法破坏的。

**因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏“互斥”条件**


（2）破坏“占有并等待”条件:

破坏“占有并等待”条件，就是在系统中不允许进程在已获得某种资源的情况下，申请其他资源。

即要想出一个办法，阻止进程在持有资源的同时申请其他资源。

方法一：创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。这
是所谓的 “ 一次性分配”方案。

方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源S
时，须先把它先前占有的资源R释放掉，然后才能提出对S的申请，即使它可能很快又要用到资源

（3）破坏“不可抢占”条件：

破坏“不可抢占”条件就是允许对资源实行抢夺。

方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有
的资源，如果有必要，可再次请求这些资源和另外的资源。

方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，
要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。

（4）破坏“循环等待”条件：
破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申
请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。



## 5，解除死锁

死锁解除的主要方法有：

1.资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防
止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。

2.撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程
优先级和撤销进程代价的高低进行。

3.进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被
剥夺。要求系统保持进程的历史信息，设置还原点。



## 6，死锁检测

死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行
的场景。
每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之
外，每当有线程请求锁，也需要记录在这个数据结构中。
当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求
锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前
所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线
程B拥有锁7，请求锁1）。
当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等
待线程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有
被B请求的锁。从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请
求的锁被线程A自己持有着。这是它就知道发生了死锁。
下面是一幅关于四个线程（A,B,C和D）之间锁占有和请求的关系图。像这样的数据结构就可以被用
来检测死锁。

一般来说，由于操作系统有并发，共享以及随机性等特点，通过预防和避免的手段达到排除死锁的
目的是很困难的。这需要较大的系统开销，而且不能充分利用资源。为此，一种简便的方法是系统
为进程分配资源时，不采取任何限制性措施，但是提供了检测和解脱死锁的手段：能发现死锁并从
死锁状态中恢复出来。因此，在实际的操作系统中往往采用死锁的检测与恢复方法来排除死锁。
死锁检测与恢复是指系统设有专门的机构，当死锁发生时，该机构能够检测到死锁发生的位置和原
因，并能通过外力破坏死锁发生的必要条件，从而使得并发进程从死锁状态中恢复出来。
这时进程P1占有资源R1而申请资源R2，进程P2占有资源R2而申请资源R1，按循环等待条件，进
程和资源形成了环路，所以系统是死锁状态。进程P1，P2是参与死锁的进程。
下面我们再来看一看死锁检测算法。算法使用的数据结构是如下这些：
占有矩阵A：nm阶，其中n表示并发进程的个数，m表示系统的各类资源的个数，这个矩阵记录了
每一个进程当前占有各个资源类中资源的个数。
申请矩阵R：nm阶，其中n表示并发进程的个数，m表示系统的各类资源的个数，这个矩阵记录了
每一个进程当前要完成工作需要申请的各个资源类中资源的个数。
空闲向量T：记录当前m个资源类中空闲资源的个数。
完成向量F：布尔型向量值为真（true）或假（false），记录当前n个并发进程能否进行完。为真即
能进行完，为假则不能进行完。
临时向量W：开始时W：=T。
算法步骤：
（1）W：=T，
对于所有的i=1，2，…，n，
如果A[i]=0，则F[i]：=true；否则，F[i]：=false
（2）找满足下面条件的下标i：
F[i]：=false并且R[i]〈=W
如果不存在满足上面的条件i，则转到步骤（4）。
（3）W：=W+A[i]
F[i]：=true
转到步骤（2）
（4）如果存在i，F[i]：=false，则系统处于死锁状态，且Pi进程参与了死锁。什么时候进行死锁的
检测取决于死锁发生的频率。如果死锁发生的频率高，那么死锁检测的频率也要相应提高，这样一
方面可以提高系统资源的利用率，一方面可以避免更多的进程卷入死锁。如果进程申请资源不能满
足就立刻进行检测，那么每当死锁形成时即能被发现，这和死锁避免的算法相近，只是系统的开销
较大。为了减小死锁检测带来的系统开销，一般采取每隔一段时间进行一次死锁检测，或者在CPU
的利用率降低到某一数值时，进行死锁的检测。