# 牛客刷题错题汇总

## 异常相关



### finally中的return问题

1，

```java
public class Test {
 public static void main(String[] args) {
     // 这里输出5
     System.out.println("return value of getValue(): " + getValue());
 }
 public static int getValue() {
     int i = 1;
     try {
         i = 4;
     } finally{
         i++;
         return i;
     }
     }
 }
```



2，以下代码执行后输出结果为（ ）

```java
public class Test {
    public static void main(String[] args) {
        System.out.println("return value of getValue(): " + getValue()); // 输出 1
    }
     public static int getValue() {
         try {
             return 0;
         } finally {
             return 1;
         }
     }
 }
```

> **如果try语句里有return，返回的是try语句块中变量值。**
>
> **如果try，finally语句里均有return，忽略try的return，而使用finally的return.**
>
> 假设利用 return 语句从 try 语句块中退出。在方法返回前，finally子句的内容将被执行。如果 finally 子句中也有一个 return 语句，这个返回值将会覆盖原始的返回值



## 类加载

### 静态代码

```java
public class Test {
    static int x=10;
    static {x+=5;}
    public static void main(String[] args) 
    {
        System.out.println("x="+x); // 这里x为5
    }
    static{x/=3;};
}/
```



2，

```java
public class Test{
    private static int i=1;
    public int getNext(){
         return i++;
    }
    public static void main(String [] args){
        Test test=new Test();
        Test testObject=new Test();
        test.getNext();
        testObject.getNext();
        System.out.println(testObject.getNext()); // 3 static的，是类属性，所以不管有多少对象，都共用的一个变量
    }
}
```



3，

```java
public class Test {
    static String x="1";
    static int y=1;
    public static void main(String args[]) {
        static int z=2;
        System.out.println(x+y+z); // 编译错误，static是类变量，不能修饰局部变量
    }
}
```



4，当你编译和运行下面的代码时，会出现下面选项中的哪种情况？

```java
public class Pvf{
    static boolean Paddy;
    public static void main(String args[]){
        System.out.println(Paddy); // 编译通过并输出结果false
    }
}
```

解析

> 类中声明的变量有默认初始值；方法中声明的变量没有默认初始值，必须在定义时初始化，否则在访问该变量时会出错。





### 父子类问题

总结

> 加载顺序：
>
> 1.父类静态代码块
>
> 2.子类静态代码块
>
> 3.父类构造代码块
>
> 4.父类构造函数
>
> 5.子类构造代码块
>
> 6.子类构造方法





1，以下程序执行的结果是：

```java
class X{
    Y y=new Y();
    public X(){
        System.out.print("X");
    }
}
class Y{
    public Y(){
        System.out.print("Y");
    }
}
public class Z extends X{
    Y y=new Y();
    public Z(){
        System.out.print("Z");
    }
    public static void main(String[] args) {
        new Z();
    }
}
```

答案：

```
YXYZ
```

解析

```
（1）初始化父类的普通成员变量和代码块，执行  Y y=new Y();  输出Y 
（2）再执行父类的构造方法；输出X
（3） 初始化子类的普通成员变量和代码块，执行  Y y=new   Y();  输出Y 
（4）再执行子类的构造方法；输出Z
```



2，对于子类的构造函数说明，下列叙述中错误的是（ ）。

正确答案: D  你的答案: A (错误)

```
子类不能继承父类的无参构造函数。
子类可以在自己的构造函数中使用super关键字来调用父类的含参数构造函数，但这个调用语句必须是子类构造函数的第一个可执行语句。
在创建子类的对象时，若不含带参构造函数，将先执行父类的无参构造函数，然后再执行自己的无参构造函数。
子类不但可以继承父类的无参构造函数，也可以继承父类的有参构造函数。
```

解析：构造函数不能被继承，构造方法只能被显式或隐式的调用。



3,以下代码执行的结果显示是多少（ ）？

```java
public class Demo {
    class Super {

        int flag = 1;

        Super() {
            test();
        }

        void test() {
            System.out.println("Super.test() flag=" + flag);
        }
    }
    class Sub extends Super {

        Sub(int i) {
            flag = i;
            System.out.println("Sub.Sub()flag=" + flag);
        }
        void test() {
            System.out.println("Sub.test()flag=" + flag);
        }
    }
    public static void main(String[] args) {
        new Demo().new Sub(5);
    }
}
```

答案

> Sub.test() flag=1
> Sub.Sub() flag=5
>
> 在只想**new** Sub(5)的时候，父类先初始化了 int flag = 1，然后执行父类的构造函数Super（），父类构造函数中执行的test（）方法，因子类是重写了test（）方法的，因此父类构造函数中的test（）方法实际执行的是子类的test（）方法，所以输出为Sub.test() flag=1，接着执行子类构造函数Sub(5) 将flag赋值为5，因此输出结果Sub.Sub() flag=5。



4，运行代码，输出的结果是（）

```java
public class P {
    public static int abc = 123;
    static{
        System.out.println("P is init");
    }
}
public class S extends P {
    static{
        System.out.println("S is init");
    }
}
public class Test {
    public static void main(String[] args) {
        System.out.println(S.abc);
    }
}
```

正确答案: A  你的答案: C (错误)

```
P is init 123
```

解析

> 不会初始化子类的几种
>
> 1. 调用的是父类的static方法或者字段
> 2. 调用的是父类的final方法或者字段
>
> 3. 通过数组来引用



5，在java中重写方法应遵循规则的包括（）

正确答案: B C  你的答案: C (错误)

```
访问修饰符的限制一定要大于被重写方法的访问修饰符
可以有不同的访问修饰符
参数列表必须完全与被重写的方法相同
必须具有不同的参数列表
```



6，对于同一类中的两个方法 , 在判断它们是不是重载方法时 , 肯定不考虑（ ）

正确答案: C  你的答案: D (错误)

```
参数个数
参数类型
返回值类型
参数顺序
```

解析

> 重载：同一个类或与他的派生类中，方法名相同，而参数列表不同的方法。其中参数列表不同指的是参数的类型，数量，类型的顺序这三种至少有一种不同。
>
> 方法重载与下列无关：与返回值类型无关；与访问修饰符无关，构造方法也可以重载
>
> 重写
>
> 重写的方法必须==方法名相同==，参数列表也相同
>
> 重写的方法的==返回值类型==应该与父类中被重写方法的返回值类型相同或是他的子类类型
>
> 重写的方法的==访问权限==应该与父类中被重写方法的访问权限相同或高于它的访问权限
>
> 重写的方法不能抛出比父类更加宽泛的==异常==
>
> 方法重写的注意事项：
>
> 构造方法不能被重写
>
> private修饰的成员方法不能被重写
>
> static修饰的方法不能被重写
>
> final修饰的方法不能被重写
>
> 当子类重写了父类中的方法后，子类对象调用该方法时调用的是子类重写后的方法



7，检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。

```java
public class HelloB extends HelloA 
{
    public HelloB()
    {
    }
    {
        System.out.println("I’m B class");
    }
    static
    {
        System.out.println("static B");
    }
    public static void main(String[] args)
    {
        new HelloB();
    }
}
class HelloA
{
    public HelloA()
    {
    }
    {
        System.out.println("I’m A class");
    }
    static
    {
        System.out.println("static A");
    }
}
```

答案

> ```
> static A
> static B
> I’m A class
> I’m B class
> ```

解析

> 1.静态代码块 2.构造代码块3.构造方法



8，在java中，下列对继承的说法，正确的是（ ）

正确答案: A  你的答案: B (错误)

```
子类能继承父类的所有成员
子类继承父类的非私有方法和状态
子类只能继承父类的public方法和状态
子类只能继承父类的方法
```

解析

> 能继承，不代表能访问



9，

```java
class Person {
    String name = "No name";
    public Person(String nm) {
        name = nm;
    }
}
class Employee extends Person {
    String empID = "0000";
    public Employee(String id) {
        empID = id;
    }
}
public class Test {
    public static void main(String args[]) {
        Employee e = new Employee("123"); // 编译出错
        System.out.println(e.empID);
    }
}
```

解析

>  子类的构造方法总是先调用父类的构造方法，如果子类的构造方法没有明显地指明使用父类的哪个构造方法，子类就调用父类不带参数的构造方法。
> 而父类没有无参的构造函数，所以子类需要在自己的构造函数中显示的调用父类的构造函数。





10，

```java
class Animal{
    public void move(){
        System.out.println("动物可以移动");
    }
}
class Dog extends Animal{
    public void move(){
        System.out.println("狗可以跑和走");
    }
    public void bark(){
        System.out.println("狗可以吠叫");
    }
}
public class TestDog{
    public static void main(String args[]){
        Animal a = new Animal();
        Animal b = new Dog(); 
        a.move();
        b.move();
        b.bark(); // 编译错误
    }
}
```

解析

> 编译看左边，运行看右边。也就是是编译的时候会把它当成左边的类型，运行的时候看右边类型的方法体。这个题动物类没有另一个方法，而b调用了，所以编译器会认为b是一个动物类，所以报错。



11，

```java
class Test {
    public static void main(String[] args) {
        System.out.println(new B().getValue()); // 22 34 17
    }
    static class A {
        protected int value;
        public A (int v) {
            setValue(v);
        }
        public void setValue(int value) {
            this.value= value;
        }
        public int getValue() {
            try {
                value ++;
                return value;
            } finally {
                this.setValue(value);
                System.out.println(value);
            }
        }
    }
    static class B extends A {
        public B () {
            super(5);
            setValue(getValue()- 3);
        }
        public void setValue(int value) {
            super.setValue(2 * value);
        }
    }
}
```



### 重写重载

1，根据下面这个程序的内容，判断哪些描述是正确的：（ ）

```java
public class Test {
    public static void main(String args[]) {
        String s = "tommy";
        Object o = s;
        sayHello(o); //语句1 语句1输出为:Welcome, tommy
        sayHello(s); //语句2 语句2输出为:Hello, tommy
    }
    public static void sayHello(String to) {
        System.out.println(String.format("Hello, %s", to));
    }
    public static void sayHello(Object to) {
        System.out.println(String.format("Welcome, %s", to));
    }
}

```

解析

> 如A a = new B(); 会使用类型B去查找重写的方法，使用类型A去查找重载的方法。
>
> 这题就考的就是关于函数重载可能出现的二义性：编译器不知道选择哪一个函数。因为无论是s还是o都可以选择public static void sayHello(Object to)。
>
> 如果代码出现了这种可能出现二义性的代码，编译器就会去寻找最适配的选项进行执行，所以s会选择public static void sayHello(String to),因为s选择这一个方法可以不经过任何的隐式转化，所以在这里选择这一个方法最适配。

## 基础语法

### 函数传递

1，指出下列程序运行的结果：

```java
public class Example{
    String str=new String("tarena");
    char[]ch={'a','b','c'};
    public static void main(String args[]){
        Example ex=new Example();
        ex.change(ex.str,ex.ch);
        System.out.print(ex.str+" and ");
        System.out.print(ex.ch);
    }
    public void change(String str,char ch[]){
   //引用类型变量，传递的是地址，属于引用传递。
        str="test ok";
        ch[0]='g';
    }
}
```

答案:

```
tarena and gbc
```



2，执行以下程序后的输出结果是（）

```
public class Test {
    public static void main(String[] args) {
        StringBuffer a = new StringBuffer("A"); 
        StringBuffer b = new StringBuffer("B"); 
        operator(a, b); 
        System.out.println(a + "," + b); 
    } 
    public static void operator(StringBuffer x, StringBuffer y) { 
        x.append(y); y = x; 
    }
}
```

答案：AB,B

解析

> a，b分别指向了A,B两个地址的值
>
> 进入方法后，x，y也指向了A，B，执行方法后，修改了A地址的值为AB
>
> 方法结束，局部变量清除
>
> a指向的数据变成了AB



3，给出以下代码,请给出结果.

```java
class Two{
    Byte x; // Byte是byte的包装类型，初始化为null而不是0
}
class PassO{
    public static void main(String[] args){
        PassO p=new PassO();
        p.start();
    }
    void start(){
        Two t=new Two();
        System.out.print(t.x+””); // null
        Two t2=fix(t);
        System.out.print(t.x+” ” +t2.x); // 42 42
    }
    Two fix(Two tt){
        tt.x=42;
        return tt;
    }
}

```









### 基本数据类型

1，如下代码，执行test()函数后，屏幕打印结果为

```java
public class Test2
{
    public void add(Byte b)
    {
        b = b++;
    }
    public void test()
    {
    	// Byte 范围时 -128~127之间，127+1越界变成-128
        Byte a = 127;
        Byte b = 127;
        add(++a);
        System.out.print(a + " ");
        add(b);
        System.out.print(b + "");
    }
}
```

结果

```
-128 127
```



2，关于下面的一段代码，以下哪些说法是正确的：

```java
public static void main(String[] args) {
    String a = new String("myString");
    String b = "myString";
    String c = "my" + "String";
    String d = c;
    System.out.print(a == b); // false
    System.out.print(a == c); // false
    System.out.print(b == c); // true
    System.out.print(b == d); // true
}
```



3，

```java
public class Test {
    public static void main(String args[]) {
        int x = -5;
        int y = -12;
        System.out.println(y % x); //-2取模运算，余数的符号跟被除数符号相同
    }
}
```

正确答案: D  你的答案: B (错误)



4,下面赋值语句中正确的是（）

正确答案: A  你的答案: D (错误)

```java
double d=5.3e12;
float f=11.1; // 差f，11.1是double
int i=0.0; // 0.0 为double 转 int 需要强制转换
Double oD=3; // 会有装箱操作，int装为Double，失败
```



5，下列在Java语言中关于数据类型和包装类的说法，正确的是（）

正确答案: B  你的答案: C (错误)

```
基本（简单）数据类型是包装类的简写形式，可以用包装类替代基本（简单）数据类型
long和double都占了64位（64bit）的存储空间。
默认的整数数据类型是int，默认的浮点数据类型是float。
和包装类一样，基本（简单）数据类型声明的变量中也具有静态方法，用来完成进制转化等。
```

解析

> 1、整数类型byte（1个字节）short（2个字节）int（4个字节）long（8个字节）
>
> 2、字符类型char（2个字节）
>
> 3、浮点类型float（4个字节）double（8个字节）



6，Which lines of the following will produce an error?

```java
byte a1 = 2, a2 = 4, a3;
short s = 16;
a2 = s; // 报错，short转byte
a3 = a1 * a2;// 报错，运算会转为int，int转byte报错
```



7，下面这段java代码，当 T 分别是引用类型和值类型的时候，分别产生了多少个 T对象和T类型的值（1,2）

```
T t = new T();(值类型时:T t;)
Func(t);
Func 定义如下：
public void Func(T t) {  }
```





### String类

1，String s = new String("xyz");创建了几个StringObject？2个

解析

> 第一种方式: String str1 = "aaa"; 是在常量池中获取对象("aaa" 属于字符串字面量，因此编译时期会在常量池中创建一个字符串对象)，
>
> 第二种方式: String str2 = new String("aaa") ; 一共会创建两个字符串对象一个在堆中，一个在常量池中（前提是常量池中还没有 "aaa" 字符串对象）。







### 注解

1，在程序代码中写的注释太多，会使编译后的程序尺寸变大。

正确答案: B  你的答案: A (错误)

```
正确
错误
```

解析

> javadoc 用来识别注释
> javac 用来识别代码
> 二者互不影响



### 类和接口

1，在JDK1.7中，下述说法中抽象类与接口的区别与联系正确的有哪些？

正确答案: A B C D  你的答案: A C D (错误)

```
抽象类中可以有普通成员变量，接口中没有普通成员变量。
抽象类和接口中都可以包含静态成员常量。
一个类可以实现多个接口，但只能继承一个抽象类
抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法。
```



2，关于 访问权限说法正确 的是 ？ (   )

正确答案: D  你的答案: 空 (错误)

```
外部类定义前面可以修饰public,protected和private
局部内部类前面可以修饰public,protected和private
匿名内部类前面可以修饰public,protected和private
以上说法都不正确
```

解析

> 对于外部类来说，只有两种修饰，public和默认（default），因为外部类放在包中，只有两种可能，包可见和包不可见。
>
> 对于内部类来说，可以有所有的修饰，因为内部类放在外部类中，与成员变量的地位一致，所以有四种可能。



3，jdk1.8中，下面有关java 抽象类和接口的区别，说法错误的是？

正确答案: B D  你的答案: A D (错误)

```
抽象类可以有构造方法，接口中不能有构造方法
抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法
一个类可以实现多个接口，但只能继承一个抽象类
接口中可以有普通成员变量，抽象类中没有普通成员变量
```

解析

> **抽象类**
>
> 特点:
>
> 1.抽象类中可以构造方法
>
> 2.抽象类中可以存在普通属性，方法，静态属性和方法。
>
> 3.抽象类中可以存在抽象方法。
>
> 4.如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。
>
> 5.抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。
>
> **接口**
>
> 1.在接口中只有方法的声明，没有方法体。
>
> 2.在接口中只有常量，因为定义的变量，在编译的时候都会默认加上 public static final 
>
> 3.在接口中的方法，永远都被public来修饰。
>
> 4.接口中没有构造方法，也不能实例化接口的对象。
>
> 5.接口可以实现多继承
>
> 6.接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法，就会报错
>
> 7.则实现类定义为抽象类。





### 关键字

1，以下说法错误的是（ ）

正确答案: A B  你的答案: A C D (错误)

```
final修饰的方法不能被重载
final可以修饰类、接口、抽象类、方法和属性
final修饰的方法也不能被重写
final修饰的属性是常量，不可以修改
```

2，在java7中，下列不能做switch()的参数类型是？

正确答案: D  你的答案: C (错误)

```
int型
枚举类型
字符串
浮点型
```

解析：switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型。**String类型是java7开始支持。**





### 运算符

1，以下JAVA程序的运行结果是什么( )

```java
public static void main(String[] args) {
    Object o1 = true ? new Integer(1) : new Double(2.0);
    Object o2;
    if (true) {
    o2 = new Integer(1);
    } else {
        o2 = new Double(2.0);
    }
    System.out.print(o1);// 1.0
    System.out.print(" ");         
    System.out.print(o2);//1
}
```

解析

> 三元运算符会对两个结果的数据类型，进行自动的类型提升





### 类库方法

Math.floor(-8.5)=( )

正确答案: D  你的答案: A (错误)

```
(float)-8.0
(long)-9
(long)-8
(double)-9.0
```

解析：Math.floor(x) 返回小于等于x的最接近整数，类型为double



2，java中下面哪些是Object类的方法（）

正确答案: A B D  你的答案: A B (错误)

```
notify()
notifyAll()
sleep()
wait()
```

解析

> 1. clone();
> 2. equals();
> 3. finalize();
> 4. getClass();[align=left][/align]
> 5. notify(),notifyAll();
> 6. hashCode();
> 7. toString();
> 8. wait();



3，以下代码将打印出

```java
 public static void main (String[] args) { 
    String classFile = "com.jd.". replaceAll(".", "/") + "MyClass.class";
    System.out.println(classFile); // ///////MyClass.class
}
```

解析

> 由于replaceAll方法的第一个参数是一个正则表达式，而"."在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成"/"。
>
> 如果想替换的只是"."，那么要写成"\\."



### 构造方法

1，下列有关java构造函数叙述正确的是（）

正确答案: C D  你的答案: B C D (错误)

```
构造器的返回值为void类型
如果一个源文件中有多个类，那么构造器必须与公共类同名
构造器可以有0个，1个或一个以上的参数
每个类可以有一个以上的构造器
```







## IO

下面哪些Java中的流对象是字节流?

```
FileInputStream
BufferedInputStream
PushbackInputStream
ByteArrayInputStream
```

答案：全部都是





## JVM虚拟机

### 堆

假如某个JAVA进程的JVM参数配置如下：

```
-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3
```

请问eden区最终分配的大小是多少？

正确答案: C  你的答案: 空 (错误)

```
64M
500M
300M
100M
```

解析

> -Xms：1G ， 就是说初始堆大小为1G 
> -Xmx：2G ， 就是说最大堆大小为2G 
> -Xmn：500M ，就是说年轻代大小是500M（包括一个Eden和两个Survivor） 
> -XX:MaxPermSize：64M ， 就是说设置持久代最大值为64M 
> -XX:+UseConcMarkSweepGC ， 就是说使用使用CMS内存收集算法 
> -XX:SurvivorRatio=3 ， 就是说Eden区与Survivor区的大小比值为3：1：1
>
> 题目中所问的Eden区的大小是指年轻代的大小，直接根据-Xmn：500M和-XX:SurvivorRatio=3可以直接计算得出
>
> 500M*(3/(3+1+1)) 
> =500M*（3/5） 
> =500M*0.6 
> =300M 





### 虚拟机

1，下面描述属于java虚拟机功能的是？

```
通过 ClassLoader 寻找和装载 class 文件
解释字节码成为指令并执行，提供 class 文件的运行环境
进行运行期间垃圾回收
提供与硬件交互的平台
```

答案：全部

2，命令javac-d参数的用途是？（）

正确答案: A  你的答案: 空 (错误)

```
指定编译后类层次的根目录
指定编译时需要依赖类的路径
指定编译时的编码
没有这一个参数
```



### 垃圾回收

1，以下哪项陈述是正确的？

正确答案: E  你的答案: C (错误)

```
垃圾回收线程的优先级很高，以保证不再使用的内存将被及时回收
垃圾收集允许程序开发者明确指定释放哪一个对象
垃圾回收机制保证了JAVA程序不会出现内存溢出
进入”Dead”状态的线程将被垃圾回收器回收
以上都不对
```

解析

> A: 垃圾回收在jvm中优先级相当相当低。
> B：垃圾收集器（GC）程序开发者只能推荐JVM进行回收，但何时回收，回收哪些，程序员不能控制。
> C：垃圾回收机制只是回收不再使用的JVM内存，如果程序有严重BUG，照样内存溢出。
> D：进入DEAD的线程，它还可以恢复，GC不会回收



## 并发

### 同步器

JDK提供的用于并发编程的同步器有哪些？

```
Semaphore
CyclicBarrier
CountDownLatch
Counter
```

答案：ABC



### 关键字

以下哪种JAVA得变量声明方式可以避免程序在多线程竞争情况下读到不正确的值( )

```java
volatile
static volatile
synchronized//synchronized不是修饰变量的 它修饰方法或代码块或对象
static
```

正确答案: A B  你的答案: A B C (错误)



### 线程

1，jre 判断程序是否执行结束的标准是（）

正确答案: A  你的答案: C (错误)

```
所有的前台线程执行完毕
所有的后台线程执行完毕
所有的线程执行完毕
和以上都无关
```

解析

>  后台线程：指为其他线程提供服务的线程，也称为守护线程

2，
关于下面这段Java程序，哪些描述是正确的：（ ）

```java
public class ThreadTest extends Thread {
    public void run() {
        System.out.println("In run");
        yield(); // Thread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。
        System.out.println("Leaving run"); //程序运行输出先有In run后有Leaving run
    }
    public static void main(String []argv) {
        (new ThreadTest()).start();
    }
}
```



## 分布式

在一个基于分布式的游戏服务器系统中，不同的服务器之间，哪种通信方式是不可行的（）？

```java
管道// 答案为管道
消息队列
高速缓存数据库
套接字
```

