

# 线程池

线程这个概念在JAVA中很常见，在很多情况下都需要去创建线程达到异步的操作，频繁的创建线程会导致内存开销很大，会消耗大量的时间和资源，对于高并发的场景下，这样的开销是不必要的。这样便有了线程池，当线程执行完任务后执行接下来的任务时，就可以复用已经创建好的线程，降低开销。

将任务派发给线程池时，会出现以下几种情况

1. 核心线程池未满，创建一个新的线程执行任务。
2. 如果核心线程池已满，工作队列未满，将线程存储在工作队列。
3. 如果工作队列已满，线程数小于最大线程数就创建一个新线程处理任务。
4. 如果超过大小线程数，按照拒绝策略来处理任务



**线程池不允许使用** **Executors** **去创建，要通过** **ThreadPoolExecutor****的方式原因？**

Executors创建的线程池底层也是调用 ThreadPoolExecutor，只不过使用不同的参数、队列、拒绝策略 

等,如果使用不当，会造成资源耗尽问题； 

直接使用ThreadPoolExecutor让使用者更加清楚线程池允许规则，常见参数的使用，避免风险 

常见的线程池问题： 

newFixedThreadPool和newSingleThreadExecutor: 

队列使用LinkedBlockingQueue，队列长度为 Integer.MAX_VALUE，可能造成堆积，导致OOM 

newScheduledThreadPool和newCachedThreadPool: 

线程池里面允许最大的线程数是Integer.MAX_VALUE，可能会创建过多线程，导致OOM



## 好处

- 重用存在的线程，减少对象创建销毁的开销，
- 有效的控制最大并发线程数，提高系统资源的使用率，
- 同时避免过多资源竞争，避免堵塞，且可以定时定期执行、单线程、并发数控制，配置任务过多任务后的拒绝策 

略等功能

- 不同的线程池可以适配不同的使用场景，以完成对应的需求



## 线程池分类

### newFixedThreadPool

初始化一个指定线程数的线程池，其中 corePoolSize == maxiPoolSize，使用LinkedBlockingQuene 作为阻塞队列

特点：即使当线程池没有可执行任务时，也不会释放线程



### newCachedThreadPool

初始化一个可以缓存线程的线程池，默认缓存 60s，线程池的线程数可达到Integer.MAX_VA LUE，即 2147483647，内部使用 SynchronousQueue 作为阻塞队列

特点：在没有任务执行时，当线程的空闲时间超过 keepAliveTime，会自动释放线程资源；当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销；因此，使用时要注意控制并发的任务数，防止因创建大量的线程导致而降低性能。



### newSingleThreadExecutor

初始化只有一个线程的线程池，内部使用 LinkedBlockingQueue 作为阻塞队列。
特点：如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行



### newScheduledThreadPool

初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据







## 总结

除了 newScheduledThreadPool 的内部实现特殊一点之外，其它线程池内部都是基于Thread PoolExecutor 类（Executor 的子类）实现的





# ThreadPoolExecutor

> 线程池底层实现类

ThreadPoolExecutor 是jdk自带的线程池对象

## 相关参数

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
```

参数

### corePoolSize

核心线程数，当提交一个任务时，线程池创建一个新线程执行任务

### maximumPoolSize

最大线程数

> maximumPoolSize - corePoolSize = 救急线程数

### keepAliveTime

救急线程空闲时的最大生存时间

### unit

时间单位

### workQueue

阻塞队列（juc中）

1、当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满 

2、从阻塞队列读数据时，如果队列为空，线程将会阻塞等待直到队列里面是非空的时候 

- 有界阻塞队列 ArrayBlockingQueue
- 无界阻塞队列 LinkedBlockingQueue
- 最多只有一个同步元素的队列 SynchronousQueue
- 优先队列 PriorityBlockingQueue

> 一个支持优先级的无界阻塞队列，默认情况下元素采用自然顺序升序排序，也可以自定义排序实现 Comparable接口

- DelayQueue：

延迟队列，在指定时间才能获取队列元素的功能，队列头元素是最接近过期的元素，里面的对象必须实现 java.util.concurrent.Delayed 接口并实现CompareTo和getDelay方法



### threadFactory

线程工厂（给线程取名字）

### handler

拒绝策略

- AbortPolicy：直接抛出异常，默认策略；
- CallerRunsPolicy：用调用者所在的线程来执行任务；
- DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务； 
- DiscardPolicy：直接丢弃任务；





## 工作方式

1. 线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。
2. 当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入 workQueue 队列排 队，直到有空闲的线程。
3. 如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线 程来救急。
4. 如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 下面的前 4 种实现，其它著名框架也提供了实现
   1. ThreadPoolExecutor.AbortPolicy 让调用者抛出RejectedExecutionException 异常，这是默认策略
   2. ThreadPoolExecutor.CallerRunsPolicy 让调用者运行任务
   3. ThreadPoolExecutor.DiscardPolicy 放弃本次任务
   4. ThreadPoolExecutor.DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之
   5. Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方 便定位问题
   6. Netty 的实现，是创建一个新线程来执行任务
   7. ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略
   8. PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略
5. 当高峰过去后，超过 corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制。

## 常用的线程池

### newFixedThreadPool

创建的是固定大小的线程池

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

**特点：**

- 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间
- 阻塞队列是无界的（LinkedBlockingQueue），可以放任意数量的任务
- 适用于任务量已知，相对耗时的任务

### newCachedThreadPool

创建的全部都是救急线程

```java
ExecutorService executorService = Executors.newCachedThreadPool();
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

特点

- 核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着全部都是救急线程（60s 后没有任务就回收）救急线程可以无限创建
- 队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的SynchronousQueue
  - 也就时在任务存入阻塞队列后，该线程就会阻塞，一直等待其他线程来取任务
- 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。
- 适合任务数比较密集，但每个任务执行时间较短的情况

### newSingleThreadExecutor

只会创建一个线程

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>())
        );
}
```

特点

- 线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放
- newSingleThreadExecutor 和 newFixedThreadPool 区别
  - 创建一个单线程串行执行任务，如果任务执行失败而终止，线程池还会新建一个线程，保证池的正常工作
  - Executors.newSingleThreadExecutor() 线程个数始终为 1 ，不能修改
    FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因 此不能调用 ThreadPoolExecutor 中特有的方法
  - 和Executors.newFixedThreadPool(1) 初始时为1时的区别：Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改，对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改

注意，Executors 返回线程池对象的弊端如下：

- FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。
- CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。

所以：需要使用有界的队列，控制线程的创建数量



## 常用的方法

```java
// 执行任务
void execute(Runnable command);

// 提交任务 task，用返回值 Future 获得任务执行结
//Future的原理就是利用我们之前讲到的保护性暂停模式来接受返回结果的
//主线程可以执行 FutureTask.get()方法来等待任务执行完成
<T> Future<T> submit(Callable<T> task);

// 提交 tasks 中所有任务
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)

// 提交 tasks 中所有任务，带超时时间
<T> List<Future<T>> invokeAll(
    Collection<? extends Callable<T>> tasks,
 	long timeout, 
    TimeUnit unit
);

// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消
<T> T invokeAny(Collection<? extends Callable<T>> tasks);

// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间
<T> T invokeAny(
    Collection<? extends Callable<T>> tasks,
    long timeout, 
    TimeUnit unit
)
```

关闭线程池

**shutdown**

```java
/*
	  线程池状态变为 SHUTDOWN
	- 不会接收新任务
	- 但已提交任务会执行完，包括等待队列里面的
	- 此方法不会阻塞调用线程的执行
	*/
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 修改线程池状态
        advanceRunState(SHUTDOWN);
        // 仅会打断空闲线程
        interruptIdleWorkers();
        onShutdown();
    } finally {
        mainLock.unlock();
    }
    // 尝试终结(没有运行的线程可以立刻终结)
    tryTerminate();
}
```

shutdownNow

```java
/*
	线程池状态变为 STOP
	- 不会接收新任务
	- 会将队列中的任务返回
	- 并用 interrupt 的方式中断正在执行的任务
	*/
public List<Runnable> shutdownNow() {

    List<Runnable> tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 修改线程池状态
        advanceRunState(STOP);
        // 打断所有线程
        interruptWorkers();
        // 获取队列中剩余任务
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    // 尝试终结
    tryTerminate();
    return tasks;
}
```



其他的方法

```java
// 不在 RUNNING 状态的线程池，此方法就返回 true
boolean isShutdown();
// 线程池状态是否是 TERMINATED
boolean isTerminated();
// 调用 shutdown 后，由于调用使线程结束线程的方法是异步的并不会等待所有任务运行结束就返回，因此如果它想在线程池 TERMINATED 后做些其它事情，可以利用此方法等待
boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
```



## 源码解读

使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量

```java
// Integer.SIZE 值为 32 
private static final int COUNT_BITS = Integer.SIZE - 3;
// runState is stored in the high-order bits
private static final int RUNNING    = -1 << COUNT_BITS;
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;
```

--

| **状态名称** | **高3位的值** | **描述**                                      |
| ------------ | ------------- | --------------------------------------------- |
| RUNNING      | 111           | 接收新任务，同时处理任务队列中的任务          |
| SHUTDOWN     | 000           | 不接受新任务，但是处理任务队列中的任务        |
| STOP         | 001           | 中断正在执行的任务，同时抛弃阻塞队列中的任务  |
| TIDYING      | 010           | 任务执行完毕，活动线程为0时，即将进入终结阶段 |
| TERMINATED   | 011           | 终结状态                                      |

特点

- 使用一个数来表示两个值的主要原因是：**可以通过一次CAS同时更改两个属性的值**



# 手写线程池

