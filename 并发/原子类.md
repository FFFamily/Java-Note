# JUC 原子类

CAS、Unsafe、原子类

之前的学习可以想到，针对多个线程修改统一变量的问题，我们可以使用synchronized加锁的方式

但加锁消耗资源，所以就可以使用**无锁**的方式



## CAS

### CAS概述

CAS 是 compare and swap 的缩写，即我们所说的比较交换。保证数据的原子性

cas 是一种基于乐观锁锁的操作

> 可以联想到 concurrentHashMap 的 添加加锁操作

CAS是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，经过调查发现，==其实现方式是基于硬件平台的汇编指令==，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。

CAS操作是原子性的，所以多线程并发使用CAS更新数据时，可以不使用锁。

JDK中大量使用了CAS来更新数据而防止加锁(synchronized 重量级锁)来保持原子更新。

Lock加锁，Lock底层的AQS也是基于CAS进行获取锁的





三个参数，一个当前内存值 V、旧的预期值 A、即将更新的值 B，当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B 并返回 true，否则什么都不做，并返回 false

==CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)==

如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。

CAS 是通过无限循环来获取数据的，若果在第一轮循环中，a 线程获取地址里面的值被 b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行

```java
class AccountSafe implements Account{
    AtomicInteger atomicInteger ;
    
    public AccountSafe(Integer balance){
        this.atomicInteger =  new AtomicInteger(balance);
    }
    
    @Override
    public Integer getBalance() {
        return atomicInteger.get();
    }
	// 这里我有疑问，是怎么修改的主存中的变量
    // pre 不是局部变量吗？赋值也是针对pre
    // 是自己蠢了，明显是atomicInteger调用了compareAndSet，是看看atomicInteger是否为pre值
    @Override
    public void withdraw(Integer amount) {
        // 核心代码
        while (true){
            int pre = getBalance();
            int next = pre - amount;
            // 该方法是会去比较然后赋值
            // 比较pre的值是否和主内存的一致，不一致就返回false
            if (atomicInteger.compareAndSet(pre,next)){
                break;
            }
        }
    }
}
```

### 执行流程

其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作

当执行到cas时，如果有其他的线程修改过了，那么就会进入下一个循环，直到修改成功

![](https://tutu-learn.oss-cn-hangzhou.aliyuncs.com/12.png)



### 实现原理

CAS 中有 Unsafe 类中的 compareAndSwapInt 方法， Unsafe 类中的compareAndSwapInt， 是一个本地方法，该 方 法 的 实 现 位 于 unsafe.cpp 中





###  CAS 的特点

结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。

1. CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。
2. synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。
3. CAS 体现的是无锁并发、无阻塞并发
   1. 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一
   2. 但如果竞争激烈(写操作多)，可以想到重试必然频繁发生，反而效率会受影响

### 存在的问题

#### ABA问题

1，当一个线程,取到值A，还没有修改

2，另外个线程也取到值A，并将其修改为B，然后又修改为了A，此时的A已经不是原来的那个A了

3，这个线程还是会拿到那个A，去进行操作

解决办法

ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1

从Java 1.5开始，使用 `AtomicStampedReference` 类，只要被修改过，就不会去使用了



AtomicStampedReference

只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号。使用AtomicStampedReference来解决。

```java
//创建
static AtomicStampedReference<String> ref = new AtomicStampedReference<>("A",0);
//获取版本号
int stamp = ref.getStamp();
//获取数据
int prev = ref.getReference();

// 如果版本号一致，才会返回true
ref.compareAndSet(prev, "C",stamp,stamp+1));
```



AtomicMarkableReference

当然，有时候只需要知道有没有修改过，不需要用什么版本号，只要改了就返回false

```java
//创建
static AtomicMarkableReference<String> ref = new AtomicMarkableReference<>("A",true);
// 如果之前没有被修改，那么就是将A-》B，再变为false
atomicMarkableReference.compareAndSet("A","B",true,false);
```



#### 循环时间问题

循环时间长开销大

因为cas操作在旧值不匹配的时候会自己自旋，直到匹配上，才会停止，那么就存在循环时间过长的问题，浪费CPU资源



#### 一个共享变量问题

当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁

从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作



### 面试题

- **解释下什么是 `CAS`，存在什么问题？**





## volatile

其实上面的方法，保存值用到了volatile，

获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。



###  为什么无锁效率高

1. 无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速... 恢复到高速运行，代价比较大
2. 但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。



## 原子整数

juc并发包提供了一些并发工具类

1. 原子整数
2. 原子引用
3. 原子数组
4. 字段更新器
5. 原子累加器

原子整数包括：

- AtomicInteger：整型原子类
- AtomicLong：长整型原子类
- AtomicBoolean ：布尔型原子类

常用的方法

```java
AtomicInteger i = new AtomicInteger(0);//不写参数代表0
```

-

```java
i.getAndIncrement();//获取然后自增加一
i.incrementAndGet();//自增加一然后获取
```

--

```java
i.decrementAndGet();//自减一然后获取
i.getAndDecrement();//获取然后自减一
```

--

```java
i.addAndGet(5);//自增指定数值然后获取
i.getAndAdd(5);
```

--

以上只能进行简单的操作，不能进行复杂的操作，所以有了如下API

```java
//该类由@FunctionalInterface修饰
//说明可以使用lamdm表达式
public final int getAndUpdate(IntUnaryOperator var1);
i.getAndUpdate((x)->x*7);
i.updateAndGet((x) ->x/7);
```

--

```java
i.accumulateAndGet(10,(x,y)->x+y);
public final int accumulateAndGet(int var1, IntBinaryOperator var2) {
    int var3;
    int var4;
    do {
        //获取当前的值
        var3 = this.get();
        // var3为当前值 var1为插入值
        var4 = var2.applyAsInt(var3, var1);
    } while(!this.compareAndSet(var3, var4));

    return var4;
}
```



### AtomicInteger底层实现

- CAS+volatile
- volatile保证线程的可见性，多线程并发时，一个线程修改数据，可以保证其它线程立马看到修改后的值CAS 保证数据更新的原子性。

```java
public class AtomicInteger extends Number implements java.io.Serializable {
  private static final long serialVersionUID = 6214790243416807050L;
  // 底层调用
  private static final Unsafe unsafe = Unsafe.getUnsafe();

  // 变量value的内存首地址的偏移量
  private static final long valueOffset;
  static {
    try {
      // 反射的方式获取值，value相对于当前对象的起始地址的偏移量
      valueOffset = unsafe.objectFieldOffset
        (AtomicInteger.class.getDeclaredField("value"));
    } catch (Exception ex) { throw new Error(ex); }
  }

  private volatile int value;
  // 底层都是对 unsafe 的方法调用
  public final int getAndSet(int newValue) {
    return unsafe.getAndSetInt(this, valueOffset, newValue);
  }
}
```



## 原子引用

实际代码中不可能一直都是基础类型的变量，那么就需要原子引用来保证引用类型的共享变量时线程安全的

基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用引用类型原子类。

- AtomicReference：引用类型原子类
- AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。
- AtomicMarkableReference ：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，~~也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。~~



实例一

```java
// 这样BigDecimal对象是不安全的
class DecimalAccountUnsafe implements DecimalAccount {
    BigDecimal balance;
    public DecimalAccountUnsafe(BigDecimal balance) {
        this.balance = balance;
    }
    @Override
    public BigDecimal getBalance() {
        return balance;
    }
    @Override
    public void withdraw(BigDecimal amount) {
        BigDecimal balance = this.getBalance();
        this.balance = balance.subtract(amount);
    }
}
```

改进

```java
class DecimalAccountCas implements DecimalAccount{
	//其他代码一致
    @Override
    public void withdraw(BigDecimal amount) {
        while(true){
            BigDecimal pre = balance.get();
            // 注意：这里的balance返回的是一个新的对象，即 pre!=next
            BigDecimal next = pre.subtract(amount);
            if (balance.compareAndSet(pre,next)){
                break;
            }
        }
    }
}
```



## 原子数组

使用原子的方式更新数组里的某个元素

- AtomicIntegerArray：整形数组原子类
- AtomicLongArray：长整形数组原子类
- AtomicReferenceArray ：引用类型数组原子类



其中的方法都和原子整数，原子引用的类似，只是需要加上一个索引，才能知道修改的是哪个



## 字段更新器

子弹更新器能保护某个对象的属性

利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常

```java
// 参数一是对象类
// 参数二是属性类
// 参数三是修改的字段的名称
AtomicReferenceFieldUpdater update = 	AtomicReferenceFieldUpdater.newUpdater(class,class,"filed");
```



## 原子累加器

LongAdder

性能提升的原因很简单，就是在有竞争时，设置多个累加单元(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]... 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。

```java
public static void main(String[] args) {
    for (int i = 0; i < 5; i++) {
        demo(() -> new LongAdder(), adder -> adder.increment());
    }
    for (int i = 0; i < 5; i++) {
        demo(() -> new AtomicLong(), adder -> adder.getAndIncrement());
    }

}

private static <T> void demo(Supplier<T> adderSupplier, Consumer<T> action) {
    T adder = adderSupplier.get();
    long start = System.nanoTime();
    List<Thread> ts = new ArrayList<>();
    // 4 个线程，每人累加 50 万
    for (int i = 0; i < 40; i++) {
        ts.add(new Thread(() -> {
            for (int j = 0; j < 500000; j++) {
                action.accept(adder);
            }
        }));
    }
    ts.forEach(t -> t.start());
    ts.forEach(t -> {
        try {
            t.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
    long end = System.nanoTime();
    System.out.println(adder + " cost:" + (end - start)/1000_000);
}
```



## Unsafe对象

Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得。

LockSupport的park方法，cas相关的方法底层都是通过Unsafe类来实现的。

其不能直接获取，需要反射得到

```java
static Unsafe unsafe;
static {
    try {
        // Unsafe 使用了单例模式，unsafe对象是类中的一个私有的变量
        Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
        theUnsafe.setAccessible(true);
范若若unsafe = (Unsafe) theUnsafe.get(null);
    } catch (NoSuchFieldException | IllegalAccessException e) {
        throw new Error(e);
    }
}
static Unsafe getUnsafe() {
    return unsafe;
}
```

 Unsafe 的总体功能![java-thread-x-atomicinteger-unsafe](https://pdai.tech/_images/thread/java-thread-x-atomicinteger-unsafe.png)

如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。

