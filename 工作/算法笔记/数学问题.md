

# 题目一：阶乘后的零

编号：172

描述：

给定一个整数 `n` ，返回 `n!` 结果中尾随零的数量。

提示 `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`

状态：半完成

自己的代码：自己的想法是先阶乘，然后用/10判断是否有零存在，再把那个零抹除，但是存在了死循环

```java
public static int trailingZeroes(int n) {
  int sum = 1;
  int index = 1;
  int count = -2;
  while(index < n){
    sum = sum * index;
    while(sum / 10 == 0){
      count++;
      sum = sum % 10;
    }
    index++;
  }
  return count;
}
```

修改后的第二版

解决了上述的问题，但是测试数据时 案例：15 通过不了，估计是我抹除0的操作不行 

> 在 87178291200 * 15 = 1307674368000
>
> 而抹零之后：。。。
>
> 确实不能抹零，会影响计算，个位数不会影响，但是乘数操过2位之后就不行了

```java
public static int trailingZeroes(int n) {
  int sum = 1*2*3*4;
  int index = 5;
  int count = 0;
  if(n <= 3){
    return 0;
  }
  while(index <= n){
    sum = sum * index;
    while(sum % 10 == 0){
      count++;
      sum = sum / 10;
    }
    index++;
  }
  return count;
}
```

官方答案

官方解释：n! 尾零的数量即为 n!中因子 10 的个数，而 10=2×5，因此转换成求 n! 中质因子 2 的个数和质因子 5 的个数的较小值。

由于质因子 2 的个数不会低于质因子 5 的个数，我们可以仅考虑质因子 5 的个数。

而 n! 中质因子 5 的个数等于 [1,n][1,n] 的每个数的质因子 5 的个数之和，我们可以通过遍历 [1,n][1,n] 的所有 5 的倍数求出。

```java
public int trailingZeroes(int n) {
  int ans = 0;
  for (int i = 5; i <= n; i += 5) {
    for (int x = i; x % 5 == 0; x /= 5) {
      ++ans;
    }
  }
  return ans;
}
```

