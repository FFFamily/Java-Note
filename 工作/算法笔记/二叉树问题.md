# 问题一：树的遍历

方法：递归遍历、使用队列迭代遍历、Morris 遍历

递归

```java
class Solution {
    List<Integer> res = new ArrayList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if(root == null){
            return res;
        }
        dfs(root);
        return res;
    }
    public void dfs(TreeNode root){
        res.add(root.val);
        
        if(root.left != null){
            dfs(root.left);
        }
        if(root.right != null){
            dfs(root.right);
        }
        
    }
}
```

迭代

```java

class Solution {    
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null){
            return res;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        TreeNode node = root;
        while(!deque.isEmpty() || node != null){
            while(node != null){
                res.add(node.val);
                deque.push(node);
                node = node.left;
            }
            node = deque.pop();
            node = node.right;
        }
        return res;
    }

}
```

Morris 遍历

Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：

新建临时节点，令该节点为 root；

如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；

如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点：

如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。

如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。

重复步骤 2 和步骤 3，直到遍历结束。



```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }

        TreeNode p1 = root, p2 = null;

        while (p1 != null) {
            p2 = p1.left;
            if (p2 != null) {
                while (p2.right != null && p2.right != p1) {
                    p2 = p2.right;
                }
                if (p2.right == null) {
                    res.add(p1.val);
                    p2.right = p1;
                    p1 = p1.left;
                    continue;
                } else {
                    p2.right = null;
                }
            } else {
                res.add(p1.val);
            }
            p1 = p1.right;
        }
        return res;
    }
}
```



# 题目二：二叉树层序遍历

编号：102

关键字：队列迭代、

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> deque = new LinkedList<TreeNode>();
        List<List<Integer>> res = new ArrayList<>();
        if(root == null){
            return res;
        }
        TreeNode node = root;
        deque.offer(node);
        while(!deque.isEmpty()){
            int  len = deque.size();
            List<Integer> list = new ArrayList<>();
            for(int i = 0 ; i < len ; i ++){
                TreeNode item = deque.poll();
                list.add(item.val);
                if(item.left != null){
                    deque.offer(item.left);
                }
                if(item.right != null){
                    deque.offer(item.right);
                }
            }
            res.add(list);
        }
        return res;
    }
}
```



# 问题三：树的深度

编号：剑指 55

关键字：递归遍历，分层迭代遍历（Queue）

```java
class Solution {
    int res = 0;
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        return dfs(root,0);
        
    }
    public int dfs(TreeNode node){
        if(node == null){
            return higt;
        }
        int item = Math.max(dfs(node.left),dfs(node.right))+1;
        return item;
    }
}
```



问题四：二叉树中和为某一值的路径

编号：剑指 34

关键字：递归

代码

```java
class Solution {
    List<List<Integer>> ret = new LinkedList<List<Integer>>();
  	// 使用Deque来临时保存中间值，就不是我自己想的创建List这样的老土方式了
    Deque<Integer> path = new LinkedList<Integer>();
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        dfs(root,0,target);
        return ret;
    }
    public void dfs(TreeNode node,int sum,int target){
        if(node == null){
            return;
        }
        path.offerLast(node.val);
        sum += node.val;
        if(sum == target && node.left == null && node.right == null){
            ret.add(new LinkedList<Integer>(path));
        }
        dfs(node.left,sum,target);
        dfs(node.right,sum,target);
        path.pollLast();
    }
}
```



# 问题五：序列化和反序列化二叉搜索树

编号：449

内容：序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。

设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。

编码的字符串应尽可能紧凑。

关键字：后序遍历，栈

代码

思路就是，序列化成字符串简单，后续遍历添加进集合就行

反序列化就需要多一层判断，以及要用到栈这样的数据结构

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        pushNode(root,list);
        String str = list.toString();
        return str.substring(1, str.length() - 1);
    }

    public void pushNode(TreeNode root , List<Integer> list){
        if(root == null){
            return;
        }
        pushNode(root.left,list);
        pushNode(root.right,list);
        list.add(root.val);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data.isEmpty()) {
            return null;
        }
        String[] arr = data.split(", ");
        Deque<Integer> stack = new ArrayDeque<Integer>();
        for(int i = 0 ; i < arr.length ; i ++){
            stack.push(Integer.parseInt(arr[i]));
        }
        return changeNode(Integer.MIN_VALUE,Integer.MAX_VALUE,stack);
    }
    public TreeNode changeNode(Integer lower,Integer up,Deque<Integer> deque){
        if(deque.isEmpty() || deque.peek() < lower || deque.peek() > up){
            return null;
        }
        Integer val =  deque.pop();
        TreeNode node = new TreeNode(val);
        node.right = changeNode(val,up,deque);
        node.left = changeNode(lower,val,deque);
        return node;
    }
}
```

