# 对象信息比对器





顶层接口，定义公共方法

```java
/**
 * 对象比对器，用于对比两个对象的所有属性是否完全相等
 */
public interface Equator {
    /**
     * 两个对象是否全相等
     *
     * @param first  对象1
     * @param second 对象2
     * @return 两个对象是否全相等
     */
    boolean isEquals(Object first, Object second);

    /**
     * 获取不相等的属性
     *
     * @param first  对象1
     * @param second 对象2
     * @return 不相等的属性，键为属性名，值为属性类型
     */
    List<FieldInfo> getDiffFields(Object first, Object second);
}
```



在使用一层抽象类进行方法实现，很明显的设计模式中的某个原则（忘记了）

> 只是简单的记得，这样子类就不需要完全的实现该接口的所有方法——接口隔离原则
>
> 也仅仅感觉，这个只是一个接口方法的定义
>
> 使用接口实现类的方法前需要做一层处理，所以就有了抽象类

```java

/**
 * 对比器抽象类
 */
@Data
public abstract class AbstractEquator implements Equator {
	// 存储基本的数据类型（包装类）
  private static final List<Class<?>> WRAPPER = 
    Arrays.asList(
    Byte.class, Short.class,Integer.class, Long.class, Float.class, Double.class, 				Character.class,Boolean.class, String.class
  );
  // 指定对比某些字段的集合
  private List<String> includeFields;
  // 指定排除对比某些字段的集合
  private List<String> excludeFields;
  
  // 是否只比对两个类都包含的属性，若为 true 则比对两个类字段的次，否则比对两个类字段的并集
  private boolean bothExistFieldOnly = true;

  public AbstractEquator() {
    includeFields = Collections.emptyList();
    excludeFields = Collections.emptyList();
  }

  public AbstractEquator(boolean bothExistFieldOnly) {
    includeFields = Collections.emptyList();
    excludeFields = Collections.emptyList();
    this.bothExistFieldOnly = bothExistFieldOnly;
  }


  // 指定包含或排除某些字段
  public AbstractEquator(List<String> includeFields, List<String> excludeFields) {
    this.includeFields = includeFields;
    this.excludeFields = excludeFields;
  }

  // 指定包含或排除某些字段
  public AbstractEquator(List<String> includeFields, List<String> excludeFields, boolean bothExistFieldOnly) {
    this.includeFields = includeFields;
    this.excludeFields = excludeFields;
    this.bothExistFieldOnly = bothExistFieldOnly;
  }

 
  // 判断两个对象是否相等——只要没有不相等的属性，两个对象就全相等
  @Override
  public boolean isEquals(Object first, Object second) {
    // 该方法由具体的子类实现
    List<FieldInfo> diff = getDiffFields(first, second);
    // 集合为空证明对象相等
    return diff == null || diff.isEmpty();
  }

  // 对比两个对象的指定属性是否相等,子类可以通过覆盖此方法对某些特殊属性进行比对
  protected boolean isFieldEquals(FieldInfo fieldInfo) {
    // 先判断排除，如果需要排除，则无论在不在包含范围，都一律不比对
    if (isExclude(fieldInfo)) {
      return true;
    }
    // 如果有指定需要包含的字段而且当前字段不在需要包含的字段中则不比对
    if (!isInclude(fieldInfo)) {
      return true;
    }
    return nullableEquals(fieldInfo.getFirstVal(), fieldInfo.getSecondVal());
  }

  // 确定是否需要比较这个字段，子类可以扩展这个方法，自定义判断方式
  protected boolean isInclude(FieldInfo fieldInfo) {
    // 没有指定需要包含的字段，则全部都包含
    if (includeFields == null || includeFields.isEmpty()) {
      return true;
    }
    return includeFields.contains(fieldInfo.getFieldName());
  }

  // 确定是否需要需要排除这个字段，子类可以扩展这个方法，自定义判断方式
  protected boolean isExclude(FieldInfo fieldInfo) {
    // 如果有指定需要排除的字段，而且当前字段是需要排除字段，则直接返回 true
    return excludeFields != null && !excludeFields.isEmpty() && excludeFields.contains(fieldInfo.getFieldName());
  }


  // 对比简单的数据类型
  List<FieldInfo> compareSimpleField(Object first, Object second) {
    // 基础类型直接使用Object比较
    boolean eq = Objects.equals(first, second);
    if (eq) {
      // 相同则返回空集合
      return Collections.emptyList();
    } else {
      Object obj = first == null ? second : first;
      Class<?> clazz = obj.getClass();
      // 不等的字段名称使用类的名称
      return Collections.singletonList(new FieldInfo(clazz.getSimpleName(), clazz, first, second));
    }
  }

  // 判断是否为原始数据类型
  boolean isSimpleField(Object first, Object second) {
    Object obj = first == null ? second : first;
    Class<?> clazz = obj.getClass();
    // isPrimitive 是Class方法，判断是否是基本类型
    // WRAPPER 存放基本类型Class类的集合
    // contains 判断集合是否包含指定元素
    return clazz.isPrimitive() || WRAPPER.contains(clazz);
  }

  // 根据配置的规则决定取两个对象字段的交集或并集
  Set<String> getAllFieldNames(Set<String> firstFields, Set<String> secondFields) {
    Set<String> allFields;
    // 只取交集
    if (isBothExistFieldOnly()) {
      allFields = firstFields.stream().filter(secondFields::contains).collect(Collectors.toSet());
    } else {
      // 否则取并集
      allFields = new HashSet<>(firstFields);
      allFields.addAll(secondFields);
    }
    return allFields;
  }

  private boolean nullableEquals(Object first, Object second) {
    if (first instanceof Collection
        && second instanceof Collection) {
      // 如果两个都是集合类型，尝试转换为数组再进行深度比较
      return Objects.deepEquals(((Collection) first).toArray(), ((Collection) second).toArray());
    }
    return Objects.deepEquals(first, second);
  }

}
```



最后由具体的使用类去实现该接口



```java
public class GetterBaseEquator extends AbstractEquator {
  private static final String GET = "get";
  private static final String IS = "is";
  private static final String GET_IS = "get|is";
  private static final String GET_CLASS = "getClass";
  private static final Map<Class<?>, Map<String, Method>> CACHE = new ConcurrentHashMap<>();

  public GetterBaseEquator() {
  }

  // 使用抽象父类的变量作为“局部的全局变量”，bothExistFieldOnly 是否只对比两个类都包含的字段
  public GetterBaseEquator(boolean bothExistFieldOnly) {
    super(bothExistFieldOnly);
  }

  // 道理同上，指定包含或排除某些字段
  public GetterBaseEquator(List<String> includeFields, List<String> excludeFields) {
    super(includeFields, excludeFields);
  }

  // 道理同上，指定包含或排除某些字段
  public GetterBaseEquator(List<Strin
  public GetterBaseEquator(List<String> includeFields, List<String> excludeFields, boolean bothExistFieldOnly) {
    super(includeFields, excludeFields, bothExistFieldOnly);
  }
                           
  // 实现父类方法                         
  @Override
  public List<FieldInfo> getDiffFields(Object first, Object second) {
    // 如果都为空那就直接返回空集合，也就是——对象相等
    if (first == null && second == null) {
      return Collections.emptyList();
    }
    // 先尝试判断是否为普通数据类型 isSimpleField 抽象父类方法
    if (isSimpleField(first, second)) {
      return compareSimpleField(first, second);
    }
    Set<String> allFieldNames;
    // 获取所有字段
    Map<String, Method> firstGetters = getAllGetters(first);
    Map<String, Method> secondGetters = getAllGetters(second);
    if (first == null) {
      allFieldNames = secondGetters.keySet();
    } else if (second == null) {
      allFieldNames = firstGetters.keySet();
    } else {
      allFieldNames = getAllFieldNames(firstGetters.keySet(), secondGetters.keySet());
    }
    List<FieldInfo> diffFields = new LinkedList<>();
    for (String fieldName : allFieldNames) {
      try {
        Method firstGetterMethod = firstGetters.getOrDefault(fieldName, null);
        Method secondGetterMethod = secondGetters.getOrDefault(fieldName, null);
        Object firstVal = firstGetterMethod != null ? firstGetterMethod.invoke(first) : null;
        Object secondVal = secondGetterMethod != null ? secondGetterMethod.invoke(second) : null;
        FieldInfo fieldInfo = new FieldInfo(fieldName, getReturnType(firstGetterMethod), getReturnType(secondGetterMethod));
        fieldInfo.setFirstVal(firstVal);
        fieldInfo.setSecondVal(secondVal);
        if (!isFieldEquals(fieldInfo)) {
          diffFields.add(fieldInfo);
        }
      } catch (IllegalAccessException | InvocationTargetException e) {
        throw new IllegalStateException("获取属性进行比对发生异常: " + fieldName, e);
      }
    }
    return diffFields;
  }

  private Class<?> getReturnType(Method method) {
    return method == null ? null : method.getReturnType();
  }

  /**
     * 获取类中的所有 getter 方法
     *
     * @return key -> fieldName, value -> getter
     */
  private Map<String, Method> getAllGetters(Object obj) {
    if (obj == null) {
      return Collections.emptyMap();
    }
    return CACHE.computeIfAbsent(obj.getClass(), k -> {
      Class<?> clazz = obj.getClass();
      Map<String, Method> getters = new LinkedHashMap<>(8);
      while (clazz != Object.class) {
        Method[] methods = clazz.getDeclaredMethods();
        for (Method m : methods) {
          // getter 方法必须是 public 且没有参数的
          if (!Modifier.isPublic(m.getModifiers()) || m.getParameterTypes().length > 0) {
            continue;
          }
          if (m.getReturnType() == Boolean.class || m.getReturnType() == boolean.class) {
            // 如果返回值是 boolean 则兼容 isXxx 的写法
            if (m.getName().startsWith(IS)) {
              String fieldName = uncapitalize(m.getName().substring(2));
              getters.put(fieldName, m);
              continue;
            }
          }
          // 以get开头但排除getClass()方法
          if (m.getName().startsWith(GET) && !GET_CLASS.equals(m.getName())) {
            String fieldName = uncapitalize(m.getName().replaceFirst(GET_IS, ""));
            getters.put(fieldName, m);
          }
        }
        clazz = clazz.getSuperclass(); //得到父类,然后赋给自己
      }
      return getters;
    });
  }

  /**
     * 来自commons-lang3包的StringUtils
     * <p>
     * 用于使首字母小写
     */
  private String uncapitalize(final String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
      return str;
    }
    final int firstCodepoint = str.codePointAt(0);
    final int newCodePoint = Character.toLowerCase(firstCodepoint);
    if (firstCodepoint == newCodePoint) {
      return str;
    }
    final int[] newCodePoints = new int[strLen];
    int outOffset = 0;
    newCodePoints[outOffset++] = newCodePoint;
    for (int inOffset = Character.charCount(firstCodepoint); inOffset < strLen; ) {
      final int codepoint = str.codePointAt(inOffset);
      newCodePoints[outOffset++] = codepoint;
      inOffset += Character.charCount(codepoint);
    }
    return new String(newCodePoints, 0, outOffset);
  }
}
```







另外一种

```java
public class FieldBaseEquator extends AbstractEquator {
    private static final Map<Class<?>, Map<String, Field>> CACHE = new ConcurrentHashMap<>();

    public FieldBaseEquator() {
    }

    public FieldBaseEquator(boolean bothExistFieldOnly) {
        super(bothExistFieldOnly);
    }

    public FieldBaseEquator(List<String> includeFields, List<String> excludeFields, boolean bothExistFieldOnly) {
        super(includeFields, excludeFields, bothExistFieldOnly);
    }

    /**
     * 指定包含或排除某些字段
     *
     * @param includeFields 包含字段，若为 null 或空集，则不指定
     * @param excludeFields 排除字段，若为 null 或空集，则不指定
     */
    public FieldBaseEquator(List<String> includeFields, List<String> excludeFields) {
        super(includeFields, excludeFields);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<FieldInfo> getDiffFields(Object first, Object second) {
        if (first == second) {
            return Collections.emptyList();
        }
        // 先尝试判断是否为简单数据类型
        if (isSimpleField(first, second)) {
            return compareSimpleField(first, second);
        }
        Set<String> allFieldNames;
        // 获取所有字段
        Map<String, Field> firstFields = getAllFields(first);
        Map<String, Field> secondFields = getAllFields(second);
        if (first == null) {
            allFieldNames = secondFields.keySet();
        } else if (second == null) {
            allFieldNames = firstFields.keySet();
        } else {
            allFieldNames = getAllFieldNames(firstFields.keySet(), secondFields.keySet());
        }
        List<FieldInfo> diffFields = new LinkedList<>();
        for (String fieldName : allFieldNames) {
            try {
                Field firstField = firstFields.getOrDefault(fieldName, null);
                Field secondField = secondFields.getOrDefault(fieldName, null);
                Object firstVal = null;
                Class<?> firstType = null;
                Class<?> secondType = null;
                Object secondVal = null;
                if (firstField != null) {
                    firstField.setAccessible(true);
                    firstVal = firstField.get(first);
                    firstType = firstField.getType();
                }
                if (secondField != null) {
                    secondField.setAccessible(true);
                    secondVal = secondField.get(second);
                    secondType = secondField.getType();
                }
                FieldInfo fieldInfo = new FieldInfo(fieldName, firstType, secondType);
                fieldInfo.setFirstVal(firstVal);
                fieldInfo.setSecondVal(secondVal);
                if (!isFieldEquals(fieldInfo)) {
                    diffFields.add(fieldInfo);
                }
            } catch (IllegalAccessException e) {
                throw new IllegalStateException("获取属性进行比对发生异常: " + fieldName, e);
            }
        }
        return diffFields;
    }

    private Map<String, Field> getAllFields(Object obj) {
        if (obj == null) {
            return Collections.emptyMap();
        }
        return CACHE.computeIfAbsent(obj.getClass(), k -> {
            Map<String, Field> fieldMap = new HashMap<>(8);
            Class<?> cls = k;
            while (cls != Object.class) {
                Field[] fields = cls.getDeclaredFields();
                for (Field field : fields) {
                    // 一些通过字节码注入改写类的框架会合成一些字段，如 jacoco 的 $jacocoData 字段
                    // 正常情况下这些字段都需要被排除掉
                    if (!field.isSynthetic()) {
                        fieldMap.put(field.getName(), field);
                    }
                }
                cls = cls.getSuperclass();
            }
            return fieldMap;
        });
    }
}
```