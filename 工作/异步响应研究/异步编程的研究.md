# 异步编程

> 2023 年 3 月 1日
>
> 项目中接触到了一个响应式编程
>
> 并且我们项目也是基于 Vertx 做的一层 响应式的web框架，不管是API调用，还是RPC调用，都是响应式的。也就是一步。
>
> 所以研究一下相关知识，并写下文章记录（CV）并整理

首先接触入门一步编程的文章：https://blog.csdn.net/weixin_70730532/article/details/124713967

随着RxJava、Reactor等异步框架的流行，异步编程受到了越来越多的关注，尤其是在 IO 密集型的业务场景中，相比传统的同步开发模式，异步编程的优势越来越明显。

那到底什么是异步编程？异步化真正的好处又是什么？如何选择适合自己团队的异步技术？在实施异步框架落地的过程中有哪些需要注意的地方？



## 什么是异步编程？

> Mono和Flux的理解： https://www.51cto.com/article/624995.html
>

### 响应式编程 + NIO



提到了同步和异步的区别

 nio 模式下服务响应的整体时间就会缩短，而是会提升 CPU 的利用率，因为 CPU 不再会阻塞等待（不可中断状态减少），这样 CPU 就能有更多的资源来处理其他的请求任务，相同单位时间内能处理更多的任务，所以 nio 模式带来的好处是：

提升 QPS（用更少的线程资源实现更高的并发能力）

降低 CPU 负荷,提高利用率



> 这里我也对 IO密集型和 CPU 密集型产生了疑惑
>
> **1.1、IO密集型任务**
>
> 一般来说：[文件读写](https://so.csdn.net/so/search?q=文件读写&spm=1001.2101.3001.7020)、DB读写、网络请求等。也就是一直做某些IO操作
>
> **1.2、CPU密集型任务**
>
> 一般来说：计算型代码、[Bitmap](https://so.csdn.net/so/search?q=Bitmap&spm=1001.2101.3001.7020)转换、Gson转换等、也就是一直在执行某些代码。比如for循环
>
> 两个时间概念： 执行时间和跑在CPU上的时间
>
> 这里就衍生出针对不同的任务类型需要设计不同的线程池
>
> 我也有点疑惑，我们项目中使用的Vertx作为一步框架，数据库采用的mysql存储Json，日常业务中，往往是查出一条Json，然后在业务代码层去解析之类的操作。这属于Cpu密集型操作吧？但是我们为什么会采用异步框架呢？
>
> leader说是: 相对于IO，解析Json的操作更加快



接着就是 java 中的nio

以及响应式编程的在java 中的体现

Future： **Java 对异步编程的第一个解决方案**  通常和线程池结合使用

`Future`的缺点很明显：



- 无法方便得知任务何时完成
- 无法方便获得任务结果
- 在主线程获得任务结果会导致主线程阻塞



看了一下 Future 的子类，有很多，很好奇是干嘛用的

FutureTask ： 需要提到的是由于1.8对1.7大部分内容进行了大刀阔斧的修改，1.7中FutureTask使用AQS（同步器实现），1.8中使用Unsafe类来实现

CompletableFuture ： 类是在Java 8中引入的，可以通过设置其值和状态显式来完成。 它可以用作java.util.concurrent.CompletionStage。 它支持未来完成时触发的相关函数和操作。 在Java 9中，CompletableFuture API进一步得到了增强。 以下是对API进行的相关更改。

- 支持延迟和超时。
- 改进了对子类的支持。
- 添加了新的工厂方法。



为了解决刚刚 Future 的缺点	

Google 并发包下的`listenableFuture`对 Java 原生的 future 做了扩展，顾名思义就是使用监听器模式实现的**回调机制**，所以叫可监听的 future。

```java
Futures.addCallback(listenableFuture, new FutureCallback<String>() {
    @Override
    public void onSuccess(String result) {
        System.out.println("异步结果:" + result);
    }
 
    @Override
    public void onFailure(Throwable t) {
        t.printStackTrace();
    }
}, executor);
```

这里很明显会有回调地狱

又如何解决回调地狱呢？ 那就是响应式编程

其实主要是以下两种解决方式：



- 事件驱动机制
- 链式调用(Lambda)

Java8 里的`CompletableFuture`和 Java9 的`Flow Api`勉强算是上面问题的解决方案：

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> "sdad");
    System.out.println("dasdasda");
    CompletableFuture<String> f2 = f1.thenApplyAsync(res -> {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        return res + "sda11111";
    });
    System.out.println(f2.get());

}
```

但CompletableFuture处理简单的任务可以使用，但并不是一个完整的反应式编程解决方案，在服务调用复杂的情况下，存在服务编排、上下文传递、柔性限流(背压)方面的不足

如果使用CompletableFuture面对这些问题可能需要自己额外造一些轮子，Java9 的Flow虽然是基于 Reactive Streams 规范实现的，但没有 RxJava、Project Reactor 这些异步框架丰富和强大和完整的解决方案。



jdk 9 中新增了 Flow 类，是Reactive Stream ([响应式]流/反应流) 的实现，Reactive Stream是一套基于发布/订阅模式的数据处理规范，能够以非阻塞背压方式实现数据的异步流

> 新名称：背压

其中有某些概念：发布者，订阅者，处理器

> 观察者模式怎么实现的呢？又被称为发布-订阅（Publish/Subscribe）模式
>



当然如果接口逻辑比较简单，完全可以使用listenableFuture或CompletableFuture

可以看出因为这些异步框架提供了丰富的 api，所以我们可以把主要精力**放在数据的流转上，而不是原来的逻辑控制上。这也是异步编程带来的思想上的转变。**

所以说**异步最吸引人的地方在于资源的充分利用，不把资源浪费在等待的时间上(nio)，代价是增加了程序的复杂度，而 Reactive Program 封装了这些复杂性，使其变得简单。**即以**同步的方式编码，达到异步的效果与性能,兼顾可维护性与可伸缩性**。

**Vert.x** 也算异步框架 (底层使用 netty 实现 nio, 最新版已支持 reactive stream 规范)



容错性:像 RxJava，Reactor 这些异步框架处理回调数据时一般会切换线程上下文，其实就是使用不同的线程池来隔离不同的数据流处理逻辑，

即利用异步框架支持线程池切换的特性实现**服务/接口隔离**，进而提高系统的**高可用**。

弹性：back-pressure 是一种重要的反馈机制，相比于传统的熔断限流等方式，是一种更加**柔性的自适应限流**。使得系统得以优雅地响应负载，而不是在负载下崩溃



## 异步化落地的难点及解决方案



中间件全异步牵涉到到公司中台化战略或框架部门的支持，包括公司内部常用的中间件比如 MQ、redis、dal 等，超出了本文讨论的范围，感兴趣的可以看下文章末尾的参考资料。



线程模型统一的背景在上一节异步化好处时有提到过，其实主要还是对线程池的管理，做好服务隔离

![img](https://img-blog.csdnimg.cn/img_convert/33981102308c001362e1f429102008c7.png)

. 上下文传递
改造成异步服务后，不能再使用ThreadLocal传递上下文 context，因为异步框架比如 RxJava 一般在收到通知后会先调用observeOn()方法切换成另外一个线程处理回调，比如我们在请求接口时在ThreadLocal的 context 里设置了一个值，在回调线程里从 context 里取不到这个值的，因为此时已经不是同一个ThreadLocal了，所以需要我们手动在切换上下文的时候传递 context 从一个线程到另一个线程环境，这里的代码只是提供一种解决思路，实际在使用前和使用后还要考虑清空`ThreadLocal`，因为线程有可能会回收到线程池下次复用，而不是立即清理，**这样就会污染上下文环境**。



可以将传递上下文的方法封装成公共方法，不需要每次都手动切换。



阻塞检测主要是要能及时发现我们某个异步任务长时间阻塞的发生，比如异步线程执行时间过长进而影响整个接口的响应，原来同步场景下我们的日志都是串行记录到 ES 或 Cat 上的，现在改成异步后，每次处理接口数据的逻辑可能在不同的线程中完成，这样记录的日志就需要我们主动去合并（依据具体的业务场景而定），如果日志无法关联起来，对我们排查问题会增加很多难度。所幸的是随着异步的流行，现在很多日志和监控系统都已支持异步了。

Project Reactor 自己也有阻塞检测功能，异步其他解决方案：纤程/协程



- Quasar
- Kilim
- Kotlin
- Open JDK Loom
- AJDK wisp2

目前实现异步化比较成熟的方案是 **Reactive Streams**



开始研究 一下 RxJava

百度看了下 在JAVA 项目中很少使用到 RxJava 其实也就是：ReactiveX

也是类似于 Flow 中的一种 观察者模式的 方式配置执行

```java
Observable<String> myObservable= Observable.create(subscriber->{
    subscriber.onNext("我是被观察的对象");
    subscriber.onNext("1");
});
Observer<Object> observer = new Observer<>() {
    @Override
    public void onSubscribe(Disposable d) {
        System.out.println("开始采用subscribe连接");
    }

    @Override
    public void onNext(@NonNull Object o) {
        System.out.println("对Next事件");
    }

    @Override
    public void onError(Throwable e) {
        System.out.println("对Error事件作出响应");
    }

    @Override
    public void onComplete() {
        System.out.println("对Complete事件作出响应");
    }
};
myObservable.subscribe(observer);
```



实现一下简单的版本

> 但是个人在实现中了解到，这个简单版本仅仅是利用观察者模式做了一层封装，实际调用还是同步的

被观察者

```java
public abstract class MyObservable<T> implements ObservableSource<T>{

    public static <T> MyObservable create(ObservableOnSubscribe<T> source){
        return new ObservableCreate<T>(source);
    }

    protected abstract void subscribeActual(Observer<? super T> observer);
}
```

数据发射，中间者

```java
public interface ObservableOnSubscribe<T> {
    void subscribe(ObservableEmitter<T> e) throws Exception;
}
```

最终落地的被观察者

```java
public final class ObservableCreate<T> extends MyObservable<T> {
    final ObservableOnSubscribe<T> source;//用户实现具体的数据发射操作

    public ObservableCreate(ObservableOnSubscribe<T> source) {
        this.source = source;
    }

    @Override
    public void subscribe(Observer<? super T> observer) {
//        observer = RxJavaPlugins.onSubscribe(this, observer);
        //subscribeActual核心代码！！！
        subscribeActual(observer);
    }

    @Override
    protected void subscribeActual(Observer<? super T> observer) {
        CreateEmitter<T> parent = new CreateEmitter<T>(observer);
        observer.onSubscribe(parent);
        try {
            //调用中间件ObservableOnSubscribe的订阅方法，开始调用发射数据的代码了！
            source.subscribe(parent);
        } catch (Throwable ex) {
            System.out.println("subscribeActual 方法报错" + ex.getMessage());
        }
    }

    static final class CreateEmitter<T> extends AtomicReference implements ObservableEmitter<T>,Disposable{
        //持有观察者,发射器的发送数据的方法其实是调用观察者对应的方法
        final Observer<? super T> observer;

        CreateEmitter(Observer<? super T> observer) {
            this.observer = observer;
        }

        @Override
        public void onNext(T value) {
            System.out.println(1111);
            new Thread(()-> observer.onNext(value)).start();
        }

        @Override
        public void onError(Throwable error) {
            observer.onError(error);
        }

        @Override
        public void onComplete() {
            observer.onComplete();
        }

        @Override
        public void dispose() {

        }

        @Override
        public boolean isDisposed() {
            return false;
        }
    }
}
```

观察者

```java
public interface Observer<T>{
    void onSubscribe(Disposable d);
    void onNext(T t);
    void onError(Throwable e);
    void onComplete();
}
```

具体使用

```java
public class Demo {
    public static void main(String[] args) {
        MyObservable myObservable = MyObservable.create(emitter -> emitter.onNext("1111"));
        System.out.println(1);
        Observer a = new Observer() {

            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onNext(Object o) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println(o);
            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onComplete() {

            }
        };
        System.out.println(2);
        myObservable.subscribe(a);
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println(3);
    }
}
```



并没有我想要的那种异步+响应式的效果

但是受 `Node.js` 的影响，我想要那种 `await()`  的效果

> node ： https://zhuanlan.zhihu.com/p/61807318

我只需要 await 一下，程序就会异步执行，不影响主线程的执行，在需要调用结果时会

 

研究ReactiveX 时有遇到某些概念，流事件，基于事件编程...

> 参考： https://juejin.cn/post/6844904018980896776

想自己实现一下 Reactor 模型 

> Reactor 模式也叫做反应器设计模式
>
> 参考：https://www.cnblogs.com/hama1993/p/10611229.html

参考：https://github.com/vipcxj/jasync/blob/old-javac/README_CN.md

Reactor : https://github.com/reactor/reactor/tree/1f3ae91d5eccaed2c29e7a6247cb3ac3a34c1c44

Reactor 单线程实现：https://www.cnblogs.com/hama1993/p/10611229.html

CompletableFuture使用详解：https://blog.csdn.net/sermonlizhi/article/details/123356877



ea-async: eaasync在JVM中实现异步等待方法:https://www.5axxw.com/wiki/content/zpwwel

git地址：https://github.com/electronicarts/ea-async



Reactive Streams：https://www.reactive-streams.org/





通常，由关键字修饰的方法`Async`至少包含一个[Await](https://learn.microsoft.com/en-us/dotnet/visual-basic/language-reference/modifiers/async)表达式或语句。==该方法同步运行，直到它到达第一个`Await`，此时它会暂停，直到等待的任务完成==。==同时，控制返回给方法的调用者==。如果该方法不包含`Await`表达式或语句，则该方法不会挂起并像同步方法那样执行。编译器警告会提醒您注意任何不包含的异步方法，`Await`因为这种情况可能表明存在错误。有关详细信息，请参阅[编译器错误](https://learn.microsoft.com/en-us/dotnet/visual-basic/language-reference/error-messages/bc42358)。

关键字`Async`是非保留关键字。当它修饰方法或 lambda 表达式时，它是关键字。在所有其他上下文中，它被解释为标识符。

> 
>
> 我用黄色标记了的语句有点提醒我
>
> 我一直不清楚，await 是怎么做到 不影响主线程的执行，而主线程在 需要 await 方法结果时又能拿到
>
> 这句话的意思就代表着：在 await 时，这个线程异步出去，并且等待 await 方法执行完成。但是主线程不会停止，因为是异步的，这个时候控制权归还给了主线程。在主线程需要这个结果时，从那个线程中拿到结果，去询问他是否完成（不对! 因该是哪个等待的线程告诉主线程已经完成了，可以使用，这样才是一个纯异步不阻塞主线程的处理流程）



从 await 表达式中调用时，await 表达式会检索存储在由 返回的任务中的`TaskOfT_MethodAsync`整数值（ 的值） 。有关 await 表达式的更多信息，请参阅[Await 运算符](https://learn.microsoft.com/en-us/dotnet/visual-basic/language-reference/operators/await-operator)。`leisureHours``TaskOfT_MethodAsync`



Netty 自己实现的 Future 继承了 JDK 的 Future，新增了 `sync()` 和`await()` 用于阻塞等待，还加了 Listeners，只要任务结束去回调 Listener 就可以了，那么我们就不一定要主动调用 `isDone()`来获取状态，或通过 `get()`阻塞方法来获取值。

Netty的 Future 与 Java 的 Future 虽然类名相同，但功能上略有不同，Netty 中引入了 Promise 机制。在 Java 的 Future 中，业务逻辑为一个 Callable 或 Runnable 实现类，该类的 `call()`或 `run()`执行完毕意味着业务逻辑的完结，在 Promise 机制中，可以在业务逻辑中人工设置业务逻辑的成功与失败，这样更加方便的监控自己的业务逻辑

> https://www.cnblogs.com/rickiyang/p/12742091.html



同时加上另外一个研究对象：Vertx 底层基于Netty 的 异步工具类

里面提到了蛮多概念：Future EventLoop 等等，也就需要我去研究一下Netty 以及 Nio

>  java 中 Uni 接口的应用
>
> vertx 中的 promise 实现 以及 我们为什么要 继承他然后实现自己的一套
>
> 为什么要引用github上的项目
>
> 我们实现spi去用那个大佬的逻辑是为啥
>
> vertx 异步调用的逻辑是怎么样的
>
> vertx 为什么是可以做到全异步，而不阻塞线程，并且能做到异步不阻塞拿到方法执行结果



公司参考的代码库：https://github.com/vipcxj/jasync
