# 实时数据推送



执行流程是：

web发起一次类似是http的请求，并在channelRead0方法中进行处理，并通过instanceof去判断帧对象是FullHttpRequest还是WebSocketFrame，建立连接是时候会是FullHttpRequest
在handleHttpRequest方法中去创建websocket，首先是判断Upgrade是不是websocket协议，若不是则通过sendHttpResponse将错误信息返回给客户端，紧接着通过WebSocketServerHandshakerFactory创建socket对象并通过handshaker握手创建连接
在连接创建好后的所以消息流动都是以WebSocketFrame来体现
在handlerWebSocketFrame去处理消息，也可能是客户端发起的关闭指令，ping指令等等





前端

```
import axios from "axios";
import store from "@/store";
 
//websocket
 
function initWebpack(){
    var url = store.state.url
    var wsurl = ''
    axios.get(`${url}/bcall/url`)  //这是我在从后端拿ws链接的地址
        .then((res) =>  {
            console.log(res.data.data)
            wsurl = res.data.data
            store.state.ws = new WebSocket(wsurl);
            store.state.ws.onopen = onopen;
            store.state.ws.onmessage = onmessage;
            store.state.ws.onclose = onclose;
            store.state.ws.onerror = onerror;
 
        }).catch((err)=> {
        console.log(err)
    })
 
 
 
}
function onopen() {
    console.log("连接websocket");
    var params = '{"reqtype":"Query","action":"allexts"}'
    store.state.ws.send(params)
    start();
}
function reconnect() {//重新连接
    var that = store.state;
    if(that.lockReconnect) {
        return;
    }
    that.lockReconnect = true;
    //没连接上会一直重连，设置延迟避免请求过多
    that.timeoutnum && clearTimeout(that.timeoutnum);
    that.timeoutnum = setTimeout(function () {
        //新连接
        initWebpack();
        that.lockReconnect = false;
        that.isFirstGet = true
    },5000);
}
function reset(){//重置心跳
    var that = store.state;
    //清除时间
    clearTimeout(that.timeoutObj);
    clearTimeout(that.serverTimeoutObj);
    //重启心跳
    start();
}
function start(){ //开启心跳
    console.log('开启心跳');
    var self = store.state;
    self.timeoutObj && clearTimeout(self.timeoutObj);
    self.serverTimeoutObj && clearTimeout(self.serverTimeoutObj);
    self.timeoutObj = setTimeout(function(){
        //这里发送一个心跳，后端收到后，返回一个心跳消息，
        if (self.ws.readyState === 1) {//如果连接正常
            
            self.ws.send(heartbeat); //心跳包格式需要自己确定
 
        }else{//否则重连
            reconnect();
        }
        self.serverTimeoutObj = setTimeout(function() {
            //超时关闭
            self.ws.close();
            reconnect()
        }, self.timeout);
    }, self.timeout)
}
function onmessage(e) {
    console.log('接收数据',e)
    //处理数据的地方
    reset();
}
function onclose(e) {
    console.log('websocket 断开: ',e);
 
}
function onerror(e) {
    console.log("出现错误");
    //重连
    reconnect();
}
 
 
 
 
export default {
    initWebpack,
    onmessage,
    onclose,
    onopen,
    onerror
 
}
```





继续

```
import axios from "axios";
import store from "@/store";
 
//websocket
 
function initWebpack(){
    var url = store.state.url
    var wsurl = ''
    axios.get(`${url}/bcall/url`)  //这是我在从后端拿ws链接的地址
        .then((res) =>  {
            console.log(res.data.data)
            wsurl = res.data.data
            store.state.ws = new WebSocket(wsurl);
            store.state.ws.onopen = onopen;
            store.state.ws.onmessage = onmessage;
            store.state.ws.onclose = onclose;
            store.state.ws.onerror = onerror;
 
        }).catch((err)=> {
        console.log(err)
    })
 
 
 
}
function onopen() {
    console.log("连接websocket");
    var params = '{"reqtype":"Query","action":"allexts"}'
    store.state.ws.send(params)
    start();
}
function reconnect() {//重新连接
    var that = store.state;
    if(that.lockReconnect) {
        return;
    }
    that.lockReconnect = true;
    //没连接上会一直重连，设置延迟避免请求过多
    that.timeoutnum && clearTimeout(that.timeoutnum);
    that.timeoutnum = setTimeout(function () {
        //新连接
        initWebpack();
        that.lockReconnect = false;
        that.isFirstGet = true
    },5000);
}
function reset(){//重置心跳
    var that = store.state;
    //清除时间
    clearTimeout(that.timeoutObj);
    clearTimeout(that.serverTimeoutObj);
    //重启心跳
    start();
}
function start(){ //开启心跳
    console.log('开启心跳');
    var self = store.state;
    self.timeoutObj && clearTimeout(self.timeoutObj);
    self.serverTimeoutObj && clearTimeout(self.serverTimeoutObj);
    self.timeoutObj = setTimeout(function(){
        //这里发送一个心跳，后端收到后，返回一个心跳消息，
        if (self.ws.readyState === 1) {//如果连接正常
            
            self.ws.send(heartbeat); //心跳包格式需要自己确定
 
        }else{//否则重连
            reconnect();
        }
        self.serverTimeoutObj = setTimeout(function() {
            //超时关闭
            self.ws.close();
            reconnect()
        }, self.timeout);
    }, self.timeout)
}
function onmessage(e) {
    console.log('接收数据',e)
    //处理数据的地方
    reset();
}
function onclose(e) {
    console.log('websocket 断开: ',e);
 
}
function onerror(e) {
    console.log("出现错误");
    //重连
    reconnect();
}
 
 
 
 
export default {
    initWebpack,
    onmessage,
    onclose,
    onopen,
    onerror
 
}
```





netty服务端 和 客户端连接代码均在同一个服务器上，因为如果通过网络来测试的话，带宽会影响连接数，我这边带宽是5M，导致客户端连接数到达6W多的时候 就上不去了。

netty服务端需要把内核参数修改下，才能支持百万的连接，未修改之前 只能到26w，然后就会报连接超时错误。
