# 迭代器

## 什么是迭代器

遍历集合是很常见的操作，不可能每次遍历集合都需要写一个for循环

那么就需要迭代器，迭代器提供一些接口遍历集合类方法

==java为遍历集合封装了一系列方法==



## 快速失败（fail-fast）

在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增 加、删除、修改），则会抛出 Concurrent Modification Exception。

原理

迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。

每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。



注意：这里异常的抛出条件是检测到 modCount !=expectedmodCount 这个条件。如果集合发生变化时修改 modCount 值刚好又设置为了 expectedmodCount 值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的 bug。

==场景：java.util 包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）==



> 快速失败：当在迭代一个集合的时候，如果有另外一个线程在修改这个集合，就会抛出 ConcurrentModification 异常，java.util 下都是快速失败



## 安全失败（fail-safe）

采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原 有集合内容，在拷贝的集合上进行遍历。

原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改 并不能被迭代器检测到，所以不会触发 Concurrent Modification Exception。

缺点：基于拷贝内容的优点是避免了 Concurrent Modification Exception，但同样地， 迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝， 在遍历期间原集合发生的修改迭代器是不知道的。

==场景：java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用，并发修改。==

找了一下

==发现只有一个CopyOnWriteArrayList可以使用==

CopyOnWriteArrayList为什么能解决这个问题呢？

CopyOnWrite容器即写时复制的容器。

通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。

CopyOnWriteArrayList中add/remove等写方法是需要加锁的，目的是为了避免Copy出N个副本出来，导致并发写。

但是。CopyOnWriteArrayList中的读方法是没有加锁的。



>  安全失败：在迭代时候会在集合二层做一个拷贝，所以在修改集合上层元素不会影响下层。在java.util.concurrent 下都是安全失败





# Iterable接口

- 实现该接口的对象允许使用for-each循环

> 除此以外，数组也可以用增强for循环，即 增强 for 循环也是借助迭代器进行遍历。

```java
List<Object> list = new ArrayList();
for (Object obj: list){
}
```

- jdk1.8之前`Iterable`只有一个方法`iterator()` ----迭代器

实现次接口的方法能够创建一个轻量级的迭代器，用于安全的遍历元素，移除元素，添加元素

> 涉及`fail-fast`机制
>

-  主要是用来遍历集合，它的特点是更加安全，因为可以确保，在当前遍历的集合元素被更改的时候，就会抛出 `ConcurrentModificationException` 异常

```java
Iterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();
while (iterator.hasNext()) {
  Map.Entry<Integer, String> entry = iterator.next();
  System.out.println(entry.getKey() + entry.getValue());
}
```



## 为什么要使用迭代器

使用迭代器更安全，有快速失败和安全失败等机制



## 迭代器在并发场景下如何使用

1，不使用迭代器，该用传统的循环遍历

2，加锁

3，使用线程安全的集合迭代遍历
